<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小博客">
<meta property="og:url" content="https://leiting-uncle/github.io/blog/index.html">
<meta property="og:site_name" content="小博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lei ting">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://Leiting-uncle/github.io/blog/"/>





  <title>小博客</title>
  








<meta name="generator" content="Hexo 6.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Leiting的茶会厅</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/KRL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/KRL/" itemprop="url">KRL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:06+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="krl程序">1、KRL程序</h1>
<h2 id="程序的结构与建立">1.1程序的结构与建立</h2>
<h3 id="程序接口">1.1.1程序接口</h3>
<p>当KRC1软件被安装在目录<code>“KRC：\R1\MADA\”</code>：时，下列文件可作为标准。</p>
<table>
<thead>
<tr class="header">
<th>File</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$MACHINE.DAT</td>
<td>控制器和机器人的系统数据列表和系统变量</td>
</tr>
<tr class="even">
<td>$ROBCOR.DAT</td>
<td>机器人动态模型的系统数据列表和数据</td>
</tr>
<tr class="odd">
<td>MACHINE.UPG</td>
<td>用于将来升级的系统文件</td>
</tr>
<tr class="even">
<td>ROBCOR.UPG</td>
<td>用于将来升级的系统文件</td>
</tr>
</tbody>
</table>
<p>下列文件可在目录<code>“KRC：\R1\SYSTEM\”</code>：下找到</p>
<table>
<thead>
<tr class="header">
<th>File</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$CONFIG.DAT</td>
<td>系统数据列表和一般数据</td>
</tr>
<tr class="even">
<td>BAS.SRC</td>
<td>运动控制的基本软件包</td>
</tr>
<tr class="odd">
<td>IR_STOPM.SRC</td>
<td>故障时服务功能所使用的程序</td>
</tr>
<tr class="even">
<td>SPS.SUB</td>
<td>监视使用的提交文件</td>
</tr>
</tbody>
</table>
<h3 id="文件">1.1.2 文件</h3>
<p>KRL程序由SRC和DAT文件组成。</p>
<p><strong>SRC</strong>文件包含实际的程序代码，有两个变量：<strong>DEF</strong>和<strong>DEFFCT</strong>(带返回值)。</p>
<p><strong>DAT</strong>文件包含特定的程序数据。它们的区别基于<strong>KRL</strong>文件概念：除处理顺序不同外，程序包含工业机器人完成的动作也不同。也可能是特殊的运动顺序，打开和关闭夹手，或复杂的顺序，例如有关焊枪限制的控制。</p>
<h3 id="文件结构">1.1.3文件结构</h3>
<p>KRL文件的内部结构由<strong>声明部分、指令部分和最多255个局部子程序和函数</strong>组成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEF NAME(x1：IN)</span><br><span class="line">声明</span><br><span class="line">指令</span><br><span class="line">END  </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>DEF</strong>:有的文件不带扩展名，因此在声明中前缀<strong>“DEF”</strong>。名称最多可包含24个字符，但不允许包含关键字(见[变量和声明]一节)。所有文件以<strong>“DEF”</strong>开头和<strong>“END”</strong>结束。</li>
<li><strong>声明</strong>
:程序执行前已经检查过声明，即在编译期间检查声明。声明部分不可能有指令,第一个指令开始于指令部分。<br />
</li>
<li><strong>指令</strong>
与声明不同，指令是动态的，程序处理过程中执行指令。<br />
</li>
<li><strong>数据列表</strong>
一个机器人程序可能仅包含一个单个的程序文件或一个程序文件和相关的数据表。
数据表和文件具有相同的公共名，区别仅在于扩展名不同。</li>
</ul>
<h2 id="建立和编辑程序">1.2建立和编辑程序</h2>
<h3 id="新建程序">1.2.1新建程序</h3>
<p><strong>Module：</strong>包含框架程序的一个SRC文件和DAT文件被创建。
<strong>Expert：</strong>仅包含标题DEF…和END的一个SRC文件和DAT文件被创建。
<strong>Cell：</strong>此时，仅创建一个包含SRC的框架程序。该程序用于通过中央PLC控制机器人。
<strong>Function：</strong>此时，一个包含标题DEF…和END的函数(SRC文件)被创建。
<strong>Submit：</strong>创建一个SUB文件的框架程序。Submit文件包含可以使用的指令，例如，用于循环监视(夹手等)。Submit文件工作类似于机器人，由控制器解释程序处理。
<strong>Expert
Submit：</strong>使用Submit模板，创建一个SUB文件，这时仅包含标题DEF…和END。</p>
<h3 id="编辑编译和链接程序">1.2.2 编辑、编译和链接程序</h3>
<p>通过菜单<strong>“新建”</strong>建立一个文件后，
则可以使用编辑器编辑该文件，
可使用软键<strong>“编辑”</strong>完成该操作。关闭编辑器后，则整个程序代码被<strong>编译</strong>，也就是说，原文的KRL代码被转换为能让控制器理解的语言。</p>
<p><strong>编译：</strong>该处理中，编译器检查代码和语法上的错误，如果检查到错误，则产生对应的消息和拓展名为<strong>“.ERR”.</strong>的错误文件</p>
<p><strong>链接编辑器：</strong>当通过软件“选择”装入一个程序后，建立程序所需要的所有文件和数据表被链接到一起。链接期间，检查模型是否存在，是否已经被编译和存在错误。当传输参数时，编辑器检查所传输参数的类型兼容性。如果链接期间出现错误，则产生扩展名为<strong>“.ERR”</strong>的错误文件。</p>
<p>您也可以使用一般文本编辑器写一个KRL程序，然后通过“装载”软键装入系统存储器中。这时，您必须<strong>确保完成所有的必要的初始化（例如：轴速度）
。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">下面的简单程序是一个定义轴速度和加速度的举例</span><br><span class="line">DEF PROG1()</span><br><span class="line">：-----声明部分----</span><br><span class="line">INT J</span><br><span class="line">：------指令部分-------</span><br><span class="line">$VEL_AXIS[1]=100 ；定义轴速度</span><br><span class="line">$VEL_AXIS[2]=100</span><br><span class="line">$VEL_AXIS[3]=100</span><br><span class="line">$VEL_AXIS[4]=100</span><br><span class="line">$VEL_AXIS[5]=100</span><br><span class="line">$VEL_AXIS[6]=100</span><br><span class="line"></span><br><span class="line">$ACC_AXIS[1]=100 ；定义轴加速度</span><br><span class="line">$ACC_AXIS[2]=100</span><br><span class="line">$ACC_AXIS[3]=100</span><br><span class="line">$ACC_AXIS[4]=100</span><br><span class="line">$ACC_AXIS[5]=100</span><br><span class="line">$ACC_AXIS[6]=100</span><br><span class="line"></span><br><span class="line">PTP&#123;A1 0，A2 -90，A3 90，A4 0，A5 0，A6 0&#125;</span><br><span class="line"></span><br><span class="line">FOR J=1 TO 5</span><br><span class="line">PTP &#123;A1 4&#125;</span><br><span class="line">PTP &#123;A2 -7，A3 5&#125;</span><br><span class="line">PTP &#123;A1 0，A2 -9，A3 9&#125;</span><br><span class="line">ENDFOR</span><br><span class="line"></span><br><span class="line">PTP &#123;A1 0，A2 -90，A3 90，A4 0，A5 0，A6 0&#125;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h2 id="改变程序">1.3改变程序</h2>
<h3 id="程序修改">1.3.1程序修改</h3>
<h3 id="编辑器">1.3.2编辑器</h3>
<h3 id="隐藏程序部分">1.4隐藏程序部分</h3>
<p>缺省时“折合”是“关闭”的，且只能由专家级别用户“打开”，然后用户才可以在KUKA图形用户界面(KUKAGUI)上看见信息。专家级用户在指示范围内装入相关的声明或指令<strong>“
FOLD”</strong>和<strong>“
：ENDFOLD”</strong>就可以使KRL块让一般用户看见。</p>
<p>通过按菜单键“程序”，然后选择“折合”和需要的命令，可以使程序中的折合显示或隐藏
。</p>
<p> <strong>Current FOLD opn/cls</strong>
打开或关闭编辑光标定位行的折合  <strong>All FOLDs opn</strong>
打开程序的所有折合  <strong>All FOLDs cls</strong>
关闭程序的所有折合</p>
<h3 id="程序举例">1.4.1 程序举例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DEF FOLDS( )</span><br><span class="line"></span><br><span class="line">：FOLD DECLARATION；%附加信息</span><br><span class="line">：---------声明部分--------</span><br><span class="line">EXT BAS (BAS_COMMAND：IN，REAL：IN)</span><br><span class="line">DECL AXIS HOME</span><br><span class="line">INT I</span><br><span class="line">：END FOLD</span><br><span class="line"></span><br><span class="line">：FOLD INITIALISATION</span><br><span class="line">：----------初始化--------</span><br><span class="line">INTERRUPT DECL 3 WHEN $STOPMESS==TRUE DO IR_STOPM( )</span><br><span class="line">INTERRUPT ON 3</span><br><span class="line">BAS(#INITMOV，0)初始化速度，</span><br><span class="line">：加速度，$BASE，$TOOL，等</span><br><span class="line">FOR I=1 TO 16</span><br><span class="line">$OUT[I]=FALSE</span><br><span class="line">ENDFOR</span><br><span class="line">HOME=&#123;AXIS：A10，A2-90，A390，A40，A530，A60&#125;</span><br><span class="line">：END FOLD</span><br><span class="line"></span><br><span class="line">：-------------主程序部分-----------</span><br><span class="line">PTP HOME：BCO运行</span><br><span class="line">LIN&#123;X 540，Y 630，Z 1500，A 0，B 90，C 0&#125;</span><br><span class="line">PTP HOME</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>该举例程序在屏上幕显示如下</p>
<p>打开折合时的显示：</p>
<p>对于编辑器来说“折回”仅仅是一个指令。因为其前面的分号，所以编译器把折合语句看作是一般注释。</p>
<h2 id="程序运行模式">1.5程序运行模式</h2>
<p>程序运行模式定义如何执行程序</p>
<ul>
<li><p>程序不停止</p></li>
<li><p>一步一步执行运动指令</p></li>
<li><p>单步执行。</p>
<p>所有的程序运行模式如下表说明</p></li>
</ul>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>运行模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GO</strong></td>
<td>执行程序中的所有指令，直到程序结束。</td>
</tr>
<tr class="even">
<td><strong>MSTEP</strong></td>
<td>运动步(运动指令)
程序一次执行一个运动指令，也就是说，每个运动指令后插入一个 STOP。
执行的程序不作前置处理。</td>
</tr>
<tr class="odd">
<td><strong>ISTEP</strong></td>
<td>增量步进(单步) 程序一步一步执行， 也就是说，
每个指令后插入一个STOP（包括空行） 。 执行的程序不作前置处理。</td>
</tr>
<tr class="even">
<td><strong>PSTEP</strong></td>
<td>程序单步(程序单步) 子程序被完整地执行。
执行的程序不作前置处理。</td>
</tr>
<tr class="odd">
<td><strong>CSTEP</strong></td>
<td>连续步进(运动指令)
程序一次执行一个运动指令，也就是说，每个运动指令后插入一个
STOP且精确定位。 执行的程序作前置处理。也就是说，定位为粗定位。</td>
</tr>
</tbody>
</table>
<p>可在<strong>KCP</strong>上使用状态键或通过变量“<strong><span
class="math inline">\(PRO_MODE**”选择程序运行模式**GO，MSTEP和ISTEP**。另一方面，程序运行模式**PSTEP和CSTEP**只能通过变量**“\)</span>PRO_MODE”</strong>来设置。要修改该状态，首先激活菜单函数<strong>“Monitor”--&gt;“Variable”--&gt;“Single”</strong>，然后在“名称”的文本输入框中输入变量“$PRO_MODE”和“新值”文本输入框中输入期望的新值。</p>
<h2 id="错误处理">1.6错误处理</h2>
<h3 id="view-err">view ERR</h3>
<p>使用菜单<strong>“监视”→“变量”→“修改”</strong>，您可以在线显示错误号的含义。要这样做的话，在状态窗口的<strong>“Name”</strong>文本输入框中输入字符<strong>“$”</strong>后跟错误号。本例子中，输入<strong>“$2263”</strong>,然后按回车键。</p>
<h3 id="jump-to">jump to</h3>
<p>如果现在将SRC文件(“ERROR.SRC”存在的条件下)装入编辑器，您必须进行适当的修改。闪烁光标已经自动定位在包含错误的第一行，使得修改非常方便。确保关闭受限制的可见性和可以看见DEF—行。细节可见<strong>[隐藏程序部分]</strong>。</p>
<h3 id="refresh">Refresh</h3>
<p>关闭编辑器，存储修改后的文件，按错误列表中的软键“刷新”；如果已经排除完了所有的错误，则错误列表消失。</p>
<h2 id="注释">1.7注释</h2>
<p>注释可在程序的任何位置插入。通常在其前面加<code>“：”</code></p>
<h1 id="变量和声明">2 变量和声明</h1>
<h2 id="变量和名称">2.1变量和名称</h2>
<h4 id="名称"><strong>名称</strong></h4>
<p>KRL中的名称</p>
<ul>
<li>最大长度为24个字符。</li>
<li>可以包含字母（A-Z）、数字（0－9）和符号‘—’和‘$’。</li>
<li>必须以字母开始。</li>
<li>不要使用关键字。</li>
</ul>
<blockquote>
<p>因为所有的系统变量（见2.4节）以符号<strong>‘$’</strong>开头，所以该符号在自定义名称中不能作为第一个符号。</p>
</blockquote>
<p>变量被看作是一个固定的存储器区域，变量的内容可以通过变量名称来寻址。当执行程序时，变量通过存储器位置（地址）和存储器内容（值）来表示。</p>
<h4 id="值分配"><strong>值分配</strong></h4>
<p>使用等号(=)给变量分配值。</p>
<p>不同的数据对象(见节2.2)有不同的存储器需求，所以变量的数据类型在使用前<strong>必须声明</strong></p>
<h4 id="变量周期"><strong>变量周期</strong></h4>
<p>变量的周期即该时间段内变量在存储器内存在。
取决于变量是在SRC文件或数据表中声明：</p>
<p><strong>SRC文件中声明的变量</strong>
周期受程序运行时间的限制。执行完成后存储器区域再分配，则变量值丢失。
<strong>数据表中声明的变量 (见数据表一章)</strong>
周期与程序运行时间无关，只要该数据表存在，该变量就存在。因此这种变量是永久保持的（直到系统关机）</p>
<h2 id="数据对象">2.2数据对象</h2>
<h3 id="数据对象的声明和初始化">2.2.1数据对象的声明和初始化</h3>
<h4 id="decl"><strong>DECL：</strong></h4>
<p>给一个数据类型分配一个变量名称和保留存储器空间，在KRL中须使用DECL声明来完成。</p>
<p><code>DECL INT QUANTITY，NUMBER</code></p>
<p>两个变量<code>QUANTITY</code>和<code>NUMBER</code>为<code>INTEGER</code>数据类型。
这样编译器就知道这两个变量和相关的数据类型，当使用该变量时，可检查该数据类型是否允许操作。
声明变量，如例子所述，首先是<strong>关键字</strong><code>DECL</code>，其后跟的是<strong>数据类型</strong>和<strong>分配该数据类型的变量列表</strong></p>
<blockquote>
<p>当声明变量和阵列为预定数据类型时，关键字DECL可以省略。不包括简单数据类型<code>INT，REAL，CHAR和BOOL</code>(见2.2.2一节)，结构数据类型<code>POS，E6POS，FRAME，AXIS和E6AXIS</code>(见2.2.5一节)是预定的。</p>
<p>对于数据类型是POS的变量（非阵列），声明可以省略。POS数据类型是变量的标准数据类型。
自由可定义结构或列举类型的声明中关键字DECL是包括缺少的。(见节2.2.5和2.2.6)。</p>
</blockquote>
<h4 id="初始化"><strong>初始化</strong></h4>
<p>当变量声明完成后，它的值第一次是不可用的，因为根据存储器位置的不同该值可能不同。要使变量可以开始工作，必须预设定一个特定的值。第一次<strong>给变量分配值</strong>称为初始化。</p>
<p>分配给变量的值是一个指令，因此不要在声明部分出现。初始化，可在指令的任何部分发生。理想状态下，所有<strong>声明过的变量应该是在声明部分后的初始化部分直接初始化完成</strong>。</p>
<p><strong>仅数据表中允许直接在声明行中初始化变量。</strong></p>
<h3 id="简单数据类型">2.2.2简单数据类型</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 18%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>数据类型</th>
<th>整数</th>
<th>实数</th>
<th>布尔</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>关键字</td>
<td>INT</td>
<td>REAL</td>
<td>BOOL</td>
<td>CHAR</td>
</tr>
<tr class="even">
<td>含义</td>
<td>整数</td>
<td>浮点数字</td>
<td>逻辑型</td>
<td>1个字符</td>
</tr>
<tr class="odd">
<td>值的范围</td>
<td>-2<sup>31-2</sup>31-1</td>
<td>+1.1E-38… ±3.4E+38</td>
<td>TRUE，FALSE</td>
<td>ASCII字符</td>
</tr>
</tbody>
</table>
<h4 id="int">INT</h4>
<p>如果将一个实数值分配给一个整数型变量，则该值一般被圆整(x.0到.49向下圆整，x.5到x.99向上圆整)。</p>
<blockquote>
<p>另外：整数相除的结果从小数点后被切掉，举例：7/4=1</p>
</blockquote>
<h4 id="二进制系统-十六进制系统">二进制系统 十六进制系统</h4>
<p>KRL中可使用反逗号<code>（’）</code>和二进制前缀<strong>B</strong>或十六进制前缀<strong>H</strong>表示二进制或十六进制整数。</p>
<h4 id="实数">实数</h4>
<p>以<strong>浮点形式</strong>表示，标准格式将一个数字分成<strong>固定点部分</strong>和一个<strong>指数</strong>。</p>
<h4 id="布尔">布尔</h4>
<p>布尔变量用于逻辑状态的说明（例如，输入/输出）。值仅有真或假。</p>
<h4 id="字符型">字符型</h4>
<p>字符型变量可以代表符合ASCII字符规定的一个准确的字符。给一个字符型变量分配的ASCII字符，必须位于括号<strong>(”)</strong>内。</p>
<h3 id="阵列">2.2.3阵列</h3>
<p>术语“阵列“指的是相同数据类型对象的组合产生的一个数据对象；通过下标可以寻址阵列中的独立的元素。声明如下
<code>DECL INT OTTO[7]</code></p>
<h4 id="阵列指针">阵列指针</h4>
<p>●阵列可能是任何数据类型。单独的元素也可能有复杂的数据类型(例如，阵列组成的阵列)。
●仅整数型数据类型允许作为下标。
●除常量和变量外，算术表达式也允许作为下标（见节2.3.1）。
●下标起始值通常为1。</p>
<h4 id="维阵列">2维阵列</h4>
<p>除已经讨论过的一维阵列，也就是说仅有一个下标，在KRL中还可以使用两维或三维阵列。采用
<code>DECL REAL MATRIX[7，3]</code></p>
<h4 id="三维阵列">三维阵列</h4>
<p>三维阵列可以看作是一个接一个的一些两维矩阵。第三维指示矩阵所处位置的级别（见图4）。一个三维阵列可简单地声明为一维或两维阵列，例如：
<code>DECL BOOL ARRAY_3D[5，3，4]</code></p>
<h3 id="字符串">2.2.4 字符串</h3>
<p>使用字符型数据类型，您仅可以存储一个独立的字符。要使用一串字符，例如字，您只需简单地将一个一维阵列的数据类型定义为字符型：
<code>DECL CHAR NAME[8]</code></p>
<p>如同通常一样，您可以寻址阵列NAME[
]中的单个的元素，例如：<code>NAME[3]=”G”</code></p>
<p>当然，您也可以直接输入全部字符串：<code>NAME[ ]=”ABCDEFG”</code></p>
<h3 id="结构">2.2.5结构</h3>
<p>使用声明语句<code>STRUC</code>，预先定义好的不同数据类型或预定数据类型的组合构成一个新的复合数据类型</p>
<h4 id="stru">STRU</h4>
<p>复合使用的一个典型例子是标准数据类型POS。它由文件$OPERATE.SRC中声明的6个实数值和2个整数值组成：
<code>STRUC POS REAL X，，Y，Z，A，B，C，INT S，T</code></p>
<h4 id="点分离">点分离</h4>
<p>如果，例如您现在使用结构数据类型的一个POSITION变量，您可以使用分离点给个别的元素分配值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POSITION.X=34.4</span><br><span class="line">POSITION.Y=-23.2</span><br><span class="line">POSITION.Z=100.0</span><br><span class="line">POSITION.A=90</span><br><span class="line">POSITION.B=29.5</span><br><span class="line">POSITION.C=3.5</span><br><span class="line">POSITION.S=2</span><br><span class="line">POSITION.T=6  </span><br></pre></td></tr></table></figure>
<h4 id="集合">集合</h4>
<p>或使用所谓的集合共同分配值：
<code>POSITION=&#123;X34.4，Y-23.2，Z100.0，A90，B29.5，C3.5，S2，T6&#125;</code></p>
<p>● 集合的值可以是简单的常量或它们自己的集合。 ●
不是必须在集合中指定结构中的所有组成。 ●
成分的指定顺序不必依照它们定义的顺序。 ● 集合中每个成分可能只包含一次。
● 在由结构组成阵列的情况下，一个集合定义一个单独的阵列元素的值。 ●
结构类型的名称可在一个集合的开头指定-以冒号分开。</p>
<blockquote>
<p>对于POS、E6POS、AXIS、E6AXIS和FRAME结构缺少的成分不能被改变。而对于其它集合，则不存在的成分被设置为无效的成分</p>
</blockquote>
<p>建立您自己的结构变量的步骤使用下列例子解释：</p>
<p>变量S_PARA必须由3个不同数据类型的元素组成。首先，必须建立一个满足这个要求的新的数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRUC WELDTYPE REAL V_WIRE，INT CHARAC，BOOL ARC</span><br></pre></td></tr></table></figure>
<p>建立了一个名称为<code>WELDTYPE</code>的新的数据类型(<code>WELDTYPE</code>不是一个变量!)。<strong>WELDTYPE</strong>由
<code>V_WIRE、CHARAC和ARC</code>三个成分组成。您现在可以任何新数据类型的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECL WELDTYPE S_PARA</span><br></pre></td></tr></table></figure>
<p>这样您就建立了一个数据类型为WELDTYPE的变量S_PARA。可以通过点分开单独寻址各个成分和通过集合－如上说明来寻址。</p>
<blockquote>
<p>为了更容易区分自定义数据类型和变量，新数据类型的名称以…TYPE结束。</p>
</blockquote>
<h4 id="预定义结构">预定义结构</h4>
<h4 id="几何数据类型">几何数据类型</h4>
<p><strong>AXIS，E6AXIS，POS，E6POS和FRAME</strong>的类型也称为几何数据类型，因为它们提供编程师一个简单的方法用来说明几何关系。</p>
<h3 id="列举类型">2.2.6列举类型</h3>
<p>ENUM</p>
<p>#符号</p>
<h2 id="数据处理">2.3数据处理</h2>
<h3 id="操作">2.3.1操作</h3>
<h4 id="算术操作">2.3.1.1算术操作</h4>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td>加法或正号</td>
</tr>
<tr class="even">
<td>-</td>
<td>减法或负号</td>
</tr>
<tr class="odd">
<td>*</td>
<td>乘法</td>
</tr>
<tr class="even">
<td>/</td>
<td>除法</td>
</tr>
</tbody>
</table>
<h4 id="几何操作">2.3.1.2几何操作</h4>
<p>KRL中几何操作以冒号
<code>：</code>表示。完成数据类型为<strong>FRAME</strong>和<strong>POS</strong>的操作数的框架联接（<strong>逻辑操作</strong>）。</p>
<h4 id="框架连接">框架连接</h4>
<p>框架操作是求左和右的值。<strong>最右边的结果</strong>的数据类型往往是操作数的数据类型（见表5）。</p>
<table>
<thead>
<tr class="header">
<th>左边操作数(参考CS)</th>
<th>操作</th>
<th>右边操作数(目标CS)</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>POS</td>
<td>：</td>
<td>POS</td>
<td>POS</td>
</tr>
<tr class="even">
<td>POS</td>
<td>：</td>
<td>FRAME</td>
<td>FRAME</td>
</tr>
<tr class="odd">
<td>FRAME</td>
<td>：</td>
<td>POS</td>
<td>POS</td>
</tr>
<tr class="even">
<td>FRAME</td>
<td>：</td>
<td>FRAME</td>
<td>FRAME</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果左边的操作数的数据类型是POS，进行类型匹配。POS结构指定的位置被转换为框架。意思是系统检查该位置的刀具框架。</p>
</blockquote>
<h5 id="举例">举例</h5>
<p>现在的任务就是定义工件坐标系和房间坐标系的相对关系。首先必须先定义下列框架变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FRAME TABLE，WORKPIECE，BASE</span><br></pre></td></tr></table></figure>
<p>房间坐标系已经由系统明确地指定。桌子坐标系和工件坐标系现在根据给定的约束初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TABLE=&#123;X450，Y600，Z800，A0，B0，C0&#125;</span><br><span class="line">WORKPIECE=&#123;X80，Y110，Z55，A-40，B180，C0&#125;</span><br></pre></td></tr></table></figure>
<p>使用几何操作得到工件坐标系和房间坐标系的相对关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BASE=TABLE：WORKPIECE</span><br></pre></td></tr></table></figure>
<p>在我们的案例中，BASE定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASE=&#123;X530，Y710，Z855，A140，B0，C-180&#125;</span><br><span class="line">另一个可能是：</span><br><span class="line">BASE=&#123;X530，Y710，Z855，A-40，B180，C0&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="关系操作">2.3.1.3关系操作</h4>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>说明</th>
<th>允许的数据类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>==</td>
<td>等于</td>
<td>INT，REAL，CHAR，ENUM，BOOL</td>
</tr>
<tr class="even">
<td>&lt;&gt;</td>
<td>不等于</td>
<td>INT，REAL，CHAR，ENUM，BOOL</td>
</tr>
<tr class="odd">
<td>&gt;</td>
<td>大于</td>
<td>INT，REAL，CHAR，ENUM</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>小于</td>
<td>INT，REAL，CHAR，ENUM</td>
</tr>
<tr class="odd">
<td>&gt;=</td>
<td>大于或等于</td>
<td>INT，REAL，CHAR，ENUM</td>
</tr>
<tr class="even">
<td>&lt;=</td>
<td>小于或等于</td>
<td>INT，REAL，CHAR，ENUM</td>
</tr>
</tbody>
</table>
<h4 id="逻辑操作">2.3.1.4逻辑操作</h4>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>操作数数量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NOT</td>
<td>1</td>
<td>非</td>
</tr>
<tr class="even">
<td>AND</td>
<td>2</td>
<td>逻辑与</td>
</tr>
<tr class="odd">
<td>OR</td>
<td>2</td>
<td>逻辑或</td>
</tr>
<tr class="even">
<td>EXOR</td>
<td>2</td>
<td>异或</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>NOT A</th>
<th>A AND B</th>
<th>A OR B</th>
<th>A EXOR B</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A=TRUE</td>
<td>B=TRUE</td>
<td>FALSE</td>
<td>TRUE</td>
<td>TRUE</td>
<td>FALSE</td>
</tr>
<tr class="even">
<td>A=TRUE</td>
<td>B=FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>A=FALSE</td>
<td>B=TRUE</td>
<td>TRUE</td>
<td>FALSE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>A=FALSE</td>
<td>B=FALSE</td>
<td>TRUE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
</tbody>
</table>
<h4 id="位操作">2.3.1.5位操作</h4>
<table>
<thead>
<tr class="header">
<th>操作</th>
<th>操作数数量</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>B_NOT</td>
<td>1</td>
<td>一位一位反</td>
</tr>
<tr class="even">
<td>B_AND</td>
<td>2</td>
<td>一位一位与</td>
</tr>
<tr class="odd">
<td>B_OR</td>
<td>2</td>
<td>一位一位或</td>
</tr>
<tr class="even">
<td>B_EXOR</td>
<td>2</td>
<td>一位一位异或</td>
</tr>
</tbody>
</table>
<h4 id="操作优先级">2.3.1.6操作优先级</h4>
<table>
<thead>
<tr class="header">
<th>优先级</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>NOT B_NOT</td>
</tr>
<tr class="even">
<td>2</td>
<td>* /</td>
</tr>
<tr class="odd">
<td>3</td>
<td>+ -</td>
</tr>
<tr class="even">
<td>4</td>
<td>AND B_AND</td>
</tr>
<tr class="odd">
<td>5</td>
<td>EXOR B_EXOR</td>
</tr>
<tr class="even">
<td>6</td>
<td>OR B_OR</td>
</tr>
<tr class="odd">
<td>7</td>
<td>== &lt;&gt; &lt; &gt; &gt;= &lt;=</td>
</tr>
</tbody>
</table>
<h3 id="标准函数">2.3.2标准函数</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 36%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th>说明</th>
<th>函数</th>
<th>函数的数 据类型</th>
<th>函数值的范围</th>
<th>函数的数 据类型</th>
<th>结果的范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>绝对值</strong></td>
<td><strong>ABS(X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong></td>
<td><strong>REAL</strong></td>
<td><strong>0…+∞</strong></td>
</tr>
<tr class="even">
<td><strong>平方根</strong></td>
<td><strong>SQRT(X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>0…+∞</strong></td>
<td><strong>REAL</strong></td>
<td><strong>0…+∞</strong></td>
</tr>
<tr class="odd">
<td><strong>正弦</strong></td>
<td><strong>SIN(X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong></td>
<td><strong>REAL</strong></td>
<td><strong>-1…+1</strong></td>
</tr>
<tr class="even">
<td><strong>余弦</strong></td>
<td><strong>COS(X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong></td>
<td><strong>REAL</strong></td>
<td><strong>-1…+1</strong></td>
</tr>
<tr class="odd">
<td><strong>正切</strong></td>
<td><strong>TAN(X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong>*</td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong></td>
</tr>
<tr class="even">
<td><strong>反余弦</strong></td>
<td><strong>ACOS(x)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>-1…+1</strong></td>
<td><strong>REAL</strong></td>
<td><strong>00…180</strong></td>
</tr>
<tr class="odd">
<td><strong>反正切</strong></td>
<td><strong>ATAN2(Y，X)</strong></td>
<td><strong>REAL</strong></td>
<td><strong>--∞…+∞</strong></td>
<td><strong>REAL</strong></td>
<td><strong>-900…+900</strong></td>
</tr>
<tr class="even">
<td><strong><em>900的倍数，也就是说.X≠(2k-1)</em>90，K∈N</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="系统变量和系统文件">2.4系统变量和系统文件</h2>
<blockquote>
<p>所有预定变量的列表见单独资料[系统变量]</p>
</blockquote>
<h3 id="计时器">计时器</h3>
<p>16个计时器变量<strong><span
class="math inline">\(TIMER[1]…\)</span>TIMER[16]</strong>可用于测量时间顺序，可用作“秒表”。开始和停止计时使用系统变量<strong><span
class="math inline">\(TIMER_STOP[1]…\)</span>TIMER_STOP[16]：</strong></p>
<p><strong>开始计时器4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$TIMER_STOP[4]=FALSE </span><br></pre></td></tr></table></figure>
<p><strong>关闭计时器4</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$TIMER_STOP[4]=TRUE</span><br></pre></td></tr></table></figure>
<p>使用一般变量分配可在任何时候复位有关的计时器变量。举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$TIMER[4]=0</span><br></pre></td></tr></table></figure>
<p>如果计时器变量值从负向正变化，对应的标记则设置为TRUE(暂停条件)，举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$TIMER_FLAG[4]=TRUE</span><br></pre></td></tr></table></figure>
<p>当控制器启动时，所有的计时器变量预设置为0，标记 <strong><span
class="math inline">\(TIMER_FLAG[1]……\)</span>TIMER_FLAG[16]</strong>
预设置为<strong>FALSE</strong></p>
<p>变量<strong><span
class="math inline">\(TIMER_STOP[1]……\)</span>TIMER_STOP[16]</strong>
预设置为<strong>TRUE</strong>。
计时器变量的单位是毫秒(ms)。<strong><span
class="math inline">\(TIMER[1]……\)</span>TIMER[16]和<span
class="math inline">\(TIMER_FLAG[1]……\)</span>TIMER_FLAG[16]</strong>以12ms循环更新。</p>
<h3 id="标记">标记</h3>
<p>1024个标记<strong><span
class="math inline">\(FLAG[1]…\)</span>FLAG[1024]</strong>被用作全局标记。这些布尔变量预设置为<strong>FALSE</strong>。您可以随时在用户界面上通过“监视”菜单看标记的当前值</p>
<h3 id="循环标记">循环标记</h3>
<p>KRC...中可用32个循环标记<strong><span
class="math inline">\(CYCFLAG[1]…\)</span>CYCFLAG[32]</strong>
，控制器启动后预设为<strong>FALSE</strong>。</p>
<h3 id="符号">$符号</h3>
<p>预定变量一般选择一个容易记忆的名称。以$符号开始和有意义的英文缩写组成。</p>
<p>有的预定变量针对整个KRC...控制器(例如<strong><span
class="math inline">\(ALARM_STOP**用于定义输出到到PLC的急停信号PLC).其它，然而仅用于机器人(例如**\)</span>BASE</strong>用于基本坐标系)。</p>
<p>机器人驱动器中有关控制的数据存储在目录<strong>“Steu”</strong>中，有关机器人的数据存储在目录<strong>“R1”</strong>中，并可在KUKA
GUI上显示。</p>
<p>在KRC...中还有KUKA定义的和控制软件一起的数据表。这些数据表被称为预定数据表，主要包含预定变量。</p>
<h4 id="machine.dat">$MACHINE.DAT</h4>
<p>是预定数据表，包含专有的系统变量。适配控制器和所连接机器人(运动信息，控制参数等)的机床数据。控制系统和机器人系统中都有一个$MACHINE.DAT，您不可以新建或删除现存的。
例如：</p>
<div class="line-block"><strong>$ALARM_STOP</strong> | <strong>急停信号
(控制器特有)</strong> |<br />
--------------- | ----------------------------- |<br />
<strong>$NUM_AX</strong> | <strong>机器人轴数 （机器人特有）</strong>
|</div>
<h4 id="custom.dat">$CUSTOM.DAT</h4>
<p>仅在控制系统中存在的数据表。包含可以配置或参数化特定控制函数的数据。编程师仅可以改变预定变量的值。不可以新建或删除现存的。例如：</p>
<div class="line-block"><strong>$PSER_1</strong> |
<strong>串行接口1的协议参数</strong> |<br />
------------ | ------------------------ |<br />
<strong>$IBUS_ON</strong> | <strong>激活可选的联络母线组</strong>
|</div>
<h4 id="config.dat">$CONFIG.DAT</h4>
<p>KUKA预定的数据表，不包含任何系统变量，然而，在控制级和机器人级都有一个<strong>$CONFIG.DAT</strong>可用。其中可定义长时间有效的变量、结构、通道和信号，对许多程序普通重要。
数据表分为以下几个程序块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- BAS</span><br><span class="line">-- AUTOEXT</span><br><span class="line">-- GRIPPER</span><br><span class="line">-- PERCEPT</span><br><span class="line">-- SPOT</span><br><span class="line">A10</span><br><span class="line">A50</span><br><span class="line">A20</span><br><span class="line">-- TOUCHSENSE</span><br><span class="line">-- USER  </span><br></pre></td></tr></table></figure>
<p>用户的全局声明应该输入USER程序块，因为仅该处的声明在以后的软件升级中被转移。</p>
<h4 id="robcor.dat">$ROBCOR.DAT</h4>
<p>文件<strong>$ROBCOR.DAT</strong>包含特定机器人的机器人动态模型的数据。在轨迹计划编排中需要这些数据。在文件中您不可以新建一个新变量或删除现存的。</p>
<h1 id="运动编程">3运动编程</h1>
<h2 id="不同坐标系的应用">3.1不同坐标系的应用</h2>
<p>最基本的坐标系时<strong>连接（轴指定）坐标系和笛卡尔坐标系</strong></p>
<p>KRC...中定义的角度A、B和C是绕坐标轴Z、Y和X的旋转角度。旋转的顺序必须保留。</p>
<ol type="1">
<li>绕Z轴的旋转角度为A</li>
<li>绕Y轴的旋转角度为B</li>
<li>绕X轴的旋转角度为C</li>
</ol>
<p>这个旋转顺序与众所周知的航空领域的roll--pitch—yaw角度一致。角度C对应于roll，角度B对应于pitch，角度A对应于yaw。</p>
<p>KRC...中预定了下列<strong>笛卡儿坐标系</strong></p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 12%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>坐标系</th>
<th>系统变量</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>全局坐标系</td>
<td>$WORLD</td>
<td>写保护</td>
</tr>
<tr class="even">
<td>机器人坐标系</td>
<td><span class="math inline">\(ROBROOT | 写保护(可在
R1/MADA/\)</span>MA CHINE.DAT中改 变)</td>
<td></td>
</tr>
<tr class="odd">
<td>工具坐标系</td>
<td>$TOOL*</td>
<td>可写</td>
</tr>
<tr class="even">
<td>基本(工件)坐标系</td>
<td>$BASE*</td>
<td>可写</td>
</tr>
</tbody>
</table>
<h3 id="world坐标系">world坐标系</h3>
<p>全局坐标系是固定的(=当机器人移动时坐标系不动)坐标系，用作机器人系统（机器人、支撑部分或工具）的根本坐标系。是机器人系统和单元外围装备的参考系统。</p>
<h3 id="机器人坐标系">机器人坐标系</h3>
<p>机器人坐标系位于机器人底部，是机器人机械结构的参考坐标系。起源于全局坐标系且当机器人系统交货时机器人坐标系与全局坐标系一致。与<span
class="math inline">\(WORLD的偏置关系可使用\)</span>ROBROOT定义。</p>
<h3 id="工具坐标系">工具坐标系</h3>
<p>工具坐标系的原点在刀尖上。可以以下列方法选择方位，坐标系的X轴与工具的工作方向一致，X轴的方向远离工具。工具坐标系随工具的移动而移动</p>
<h3 id="基坐标系">基坐标系</h3>
<p>基坐标系是用来定义工件位置的参考坐标系。机器人在基坐标系中编程，全局坐标系作为它的参考坐标系。在交货时，<strong><span
class="math inline">\(BASE=\)</span>WORLD</strong>。可以改变<strong>$BASE</strong>，例如当使用相同的程序加工不同位置的许多相同的工件时。</p>
<h2 id="点到点运动ptp">3.2点到点运动PTP</h2>
<p>PTP:点到点运动是将刀尖（刀具中心点：TCP）从当前位置移动到编程终点位置的最快方法。控制器计算各轴必要的角度差别。</p>
<h3 id="一般说明">3.2.1一般说明</h3>
<p>使用下列系统变量： ●<strong><span
class="math inline">\(VEL_AXIS[轴数]:编程的最大轴速度**
**●\)</span>ACC_AXIS[轴数]:编程的最大轴加速度</strong>
机床数据中所有的输入以最大值的百分比给定。对于所有轴来说，如果还没有编程这两个系统变量，执行程序则会产生相关的错误消息。</p>
<blockquote>
<p>由于在笛卡儿坐标系中的PTP运动通常不知道哪一个轴是主导轴，所以明智的做法是将所有轴设置同样的加速度和速度值。</p>
</blockquote>
<h3 id="更高级的运动轮廓">3.2.2更高级的运动轮廓</h3>
<h3 id="运动命令">3.2.3运动命令</h3>
<blockquote>
<p>程序中首先定义轴的速度和加速度，必须在执行点到点运动前分配这些值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DEFPTP_AXIS( ) ;程序名是PTP_AXIS</span><br><span class="line">$VEL_AXIS[1]=100 ；定义轴速度</span><br><span class="line">$VEL_AXIS[2]=100</span><br><span class="line">$VEL_AXIS[3]=100</span><br><span class="line">$VEL_AXIS[4]=100</span><br><span class="line">$VEL_AXIS[5]=100</span><br><span class="line">$VEL_AXIS[6]=100</span><br><span class="line"></span><br><span class="line">$ACC_AXIS[1]=100 ；定义轴加速度</span><br><span class="line">$ACC_AXIS[2]=100</span><br><span class="line">$ACC_AXIS[3]=100</span><br><span class="line">$ACC_AXIS[4]=100</span><br><span class="line">$ACC_AXIS[5]=100</span><br><span class="line">$ACC_AXIS[6]=100</span><br><span class="line">PTP&#123;AXIS：A1 0，A2 –90，A3 90，A4 0，A5 0，A6 0&#125;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h4 id="ptp">PTP</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTP&#123;A3 45&#125;  </span><br></pre></td></tr></table></figure>
<p>PTP指令中定义的角度值是绝对值。因此机器人并不是旋转45度，而是旋转到45度。</p>
<h4 id="ptp_rel">PTP_REL</h4>
<p>相对运动，使用指令PTP
REL。例如要旋转轴1和4都是35度，简单编程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PTP REL PTP REL &#123;A1 35，A4 35&#125;  </span><br></pre></td></tr></table></figure>
<p>通过POS结构在笛卡儿坐标系中输入值，如同下面的举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DEF PTP_POS( )</span><br><span class="line"></span><br><span class="line">$BASE=$WORLD ;设置基本坐标系</span><br><span class="line"></span><br><span class="line">$TOOL=$NULLFRAME  ；设置工具坐标系</span><br><span class="line"></span><br><span class="line">$VEL_AXIS[1]=100 ；定义轴速度</span><br><span class="line">$VEL_AXIS[2]=100</span><br><span class="line">$VEL_AXIS[3]=100</span><br><span class="line">$VEL_AXIS[4]=100</span><br><span class="line">$VEL_AXIS[5]=100</span><br><span class="line">$VEL_AXIS[6]=100</span><br><span class="line"></span><br><span class="line">$ACC_AXIS[1]=100 ；定义轴加速度</span><br><span class="line">$ACC_AXIS[2]=100</span><br><span class="line">$ACC_AXIS[3]=100</span><br><span class="line">$ACC_AXIS[4]=100</span><br><span class="line">$ACC_AXIS[5]=100</span><br><span class="line">$ACC_AXIS[6]=100</span><br><span class="line"></span><br><span class="line">PTP&#123;POS：X 1025，Y 0，Z 1480，A 0，B 90，C 0，S ’B010’，T ’B000010’&#125;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h4 id="坐标系">坐标系</h4>
<p>笛卡儿坐标系中使用<strong>几何操作</strong>可以直接在运动命令中进行框架联接，这种方法，例如可以不修改系统变量<strong>$BASE</strong>而初始化与基本坐标系的偏置。</p>
<blockquote>
<p>而且，通过冒号操作指定一个基本偏置比重新定义<span
class="math inline">\(BASE更有优势：运动指令中出现偏置操作，则必须在运动指令前设置\)</span>BASE。以该方法，即使停止了程序后选择后续的程序段，运动总是选择了正确的基本坐标系。</p>
<p>因此， <span class="math inline">\(BASE 和\)</span>TOOL
仅可以被设置一次，例如，在程序的初始化部分。然后可以使用几何操作进行后续的偏置。</p>
</blockquote>
<h4 id="ini">INI</h4>
<p>在这个例子中，速度和加速度及<span
class="math inline">\(BASE和\)</span>TOOL坐标系的分配不是“手动”进行，而时由标准基本软件包中的“BAS.SRC”来完成，要这样做，必须首先使用EXT指令使程序认识。
初始化命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INI BAS(#INITMOV，0)</span><br></pre></td></tr></table></figure>
<p>然后分配缺省值给所有重要的系统变量。</p>
<h4 id="bco">BCO</h4>
<blockquote>
<p>明智的做法是编程一个“Home”作为第一个运动指令；移动机器人到一个明确定义的位置，这样就确立了程序段一致性。机器人在程序的结束应返回该位置。</p>
</blockquote>
<h4 id="s和t">S和T</h4>
<p>POS定义中的“S”和“T”用于选择一个特定的，
明确定义的空间中需要许多轴定位的同一个点的机器人位置 。</p>
<p>程序的第一个运动指令必须总是一个定义了状态和转的完整的PTP指令(或一个完整的使用轴坐标系的PTP指令)。在后续的PTP指令中，只要不需要特定轴定位，例如要要避开障碍时可以省略“S”和“T”，机器人保持最短轴轨迹使用的S和T值，则在第一个PTP指令中编程
“S”和 “T”后，每次程序运行时，机器人的轨迹都相同 。</p>
<h4 id="turn">Turn</h4>
<p>属性包含“Turn”属性的扩展笛卡儿位置，可以在不需要特殊移动策略（例如辅助点）时，轴的移动角度大于+1800或小于－1800。对于旋转轴，轴值前面的各位决定符号，如下：
位x=0：轴的角度 ≥00 位x=1：轴的角度＜00</p>
<p><strong>值T‘B10011’意思是指轴1、2、5的角度是负值，而轴3、4、6是正值(高位是0可以省略)。</strong></p>
<h4 id="status">Status</h4>
<p>状态S当轴位置不明确时使用(见图18)。S根据当前机器人运动系统的不同而不同</p>
<h2
id="连续轨迹运动cp运动连续轨迹">3.3连续轨迹运动(CP运动=连续轨迹)</h2>
<h3 id="速度和加速度">3.3.1速度和加速度</h3>
<p>与PTP运动不同，在连续轨迹运动中不是只定义起点和终点，还需要定义这些点之间沿直线和圆弧轨迹的TCP运动。
输入的速度和加速率对于单独的轴或TCP的运动不再有关系，对于平移运动、旋转角和旋转的角度<strong>必须编程速度和加速度</strong>。</p>
<p>当调用基本软件包的初始化顺序时，CP运动的缺省设置速度和加速率也被预设为机床数据<strong><span
class="math inline">\(CONFIG.DAT**定义的最大值。
CP运动的轴速度和加速度被监视，监视范围在系统变量**\)</span>ACC_ACT_MA和<span
class="math inline">\(VEL_ACT_MA**定义，如果超过该范围，则触发制动反应，同时产生错误消息。标准范围是法向轴加速度的250%和法向轴速度的110%。这些监控范围对所有操作模式和手动移动都有效。要预防超过监控范围引起的反应（制动反应），可以使用系统变量**\)</span>CP_VEL_TYPE</strong>降低轴进给速、加速度和速度。该变量的缺省设置是<strong>#CONSTANT</strong>，I也就是说，在程序模式降速是不激活的。如果要在T1模式（T1模式使用更低的速度和加速度）使用该功能，必须设置值<strong>#VAR_T1</strong>，而对于所有操作模式则要设置值<strong>#VAR_ALL</strong>。在JOG模式总是激活降速。在测试模式如果降低轨迹速度，系统变量<strong>$CPVELREDMELD</strong>会产生错误消息，要这样做的话，必须分配该值为“1”。</p>
<h3 id="方位控制">3.3.2方位控制</h3>
<p>如果轨迹运动期间，要改变工具在空间中的方位，可以使用系统变量<strong>$ORI_TYPE</strong>设置为方位控制模式(见图21)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ORI_TYPE=#CONSTANT 轨迹运动期间方位保持不变；对于使用的起点和终点，编程的方位被忽略。</span><br><span class="line">$ORI_TYPE=#VAR 轨迹运动期间从最初的方位到最终的方位，方位连续变化。 该值在初始化期间通过BAS(#INITMOV，0)来设置。</span><br></pre></td></tr></table></figure>
<p>对于圆弧运动，
固定的和变化的方位外，还需要选择空间相关的方位和轨迹相关的方位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$CIRC_TYPE=#BASE 在圆弧运动期间执行空间相关的方位控制。该值也要在初始化期间通过BAS(#INITMOV，0)来设置。</span><br><span class="line">$CIRC_TYPE=#PATH  在圆弧运动期间执行轨迹相关的方位控制。</span><br></pre></td></tr></table></figure>
<h4 id="固定方位轨迹相关">固定方位＋轨迹相关</h4>
<h4 id="变化的方位轨迹相关">变化的方位+轨迹相关</h4>
<h4 id="固定方位空间相关">固定方位＋空间相关</h4>
<h4 id="变化的方位空间相关">变化的方位＋空间相关</h4>
<h3 id="线性运动">3.3.3线性运动</h3>
<h4 id="line">LINE</h4>
<p>使用关键字LIN或LIN_REL及终点定义来编程一个线性运动，类似于PTP编程。线性运动的终点以笛卡儿坐标输入。仅允许使用数据类型<strong>FRAME或POS</strong>
.</p>
<h4 id="circle">CIRCLE</h4>
<p>要明确地定义空间中的一个圆和圆弧运动，需要互相不在一条直线的三个不同点。圆弧运动的起点也是当前位置，同PTP中的LIN。</p>
<h4 id="continue">CONTINUE</h4>
<h2 id="使用逼近定位的运动">3.5使用逼近定位的运动</h2>
<h1 id="程序执行控制">5.程序执行控制</h1>
<h2 id="程序分支">5.1程序分支</h2>
<h3 id="跳跃分支">5.1.1跳跃分支</h3>
<h4 id="goto"><strong>GOTO</strong></h4>
<h3 id="条件分支">5.1.2条件分支</h3>
<h4 id="if"><strong>IF</strong></h4>
<h3 id="转换">5.1.3转换</h3>
<h4 id="switch">SWITCH</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DEF MAIN（）</span><br><span class="line">…</span><br><span class="line">SIGNAL PROG_NR $IN[1] TO $IN[4]；期望的程序号现在通过PLC存储在INT变量PROG_NO中</span><br><span class="line">…</span><br><span class="line">SWITCH PROG_NO</span><br><span class="line">	CASE 1 ；如果PROG_NO=1</span><br><span class="line">		PART_1（）</span><br><span class="line">	CASE 2 ；如果PROG_NO=2</span><br><span class="line">		PART_2（）</span><br><span class="line">		PART_2A（）</span><br><span class="line">	CASE3，4，5 ；如果PROG_NO=3，4或5</span><br><span class="line">		$OUT[3]=TRUE</span><br><span class="line">		PART_345（）</span><br><span class="line">	DEFAULT ；如果PROG_NO&lt;&gt;1，2，3，4或5</span><br><span class="line">		ERROR_UP（）</span><br><span class="line">ENDSWITCH</span><br><span class="line">…</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h2 id="循环">5.2循环</h2>
<h3 id="计数循环">5.2.1计数循环</h3>
<h4 id="for">FOR</h4>
<p>计数器中输入整数类型的表达式作为<strong>Start和End</strong>的值。
循环开始时对该表达式求值。</p>
<p>以起始值预先定义整数型变量<strong>Counter</strong>(必须提前声明)
，然后该值在每次循环执行后增加或减少编程的增量。</p>
<p><strong>Increment</strong>既不能是一个变量，也不能是零。如果没有指定增量，则使用缺省值1。允许使用负的增量值。</p>
<p>每个FOR语句必须以一个<strong>ENDFOR</strong>语句结束。</p>
<h3 id="跳出循环">5.2.2跳出循环</h3>
<h4 id="while">WHILE</h4>
<p>WHILE循环在重复开始时请求一个执行条件。它是一个跳出循环，它不是单次运行，直到开始设置的执行条件满足时才跳出。WHILE循环语法如下:</p>
<h3 id="非一跳出循环">5.2.3非一跳出循环</h3>
<h4 id="repeat">REPEAT</h4>
<p>与WHILE循环相对应的是REPEAT循环。
REPEAT,直到循环结束时才检查结束条件。因
此REPEAT循环总是运行一次，即使在循环开始前结束条件已经满足。</p>
<h3 id="无穷循环">5.2.4无穷循环</h3>
<p>只能使用EXIT语句结束指令程序段的重复执行</p>
<h3 id="循环的退出">5.2.5循环的退出</h3>
<p>使用<strong>EXIT语句</strong>可以提前结束任何循环。通过在循环的指令程序段内调用EXIT，循环运行立即结束，程序在循环结束语句后重新开始。</p>
<p>在REPEAT和WHILEl循环中选择合理的结束和执行条件而不必主要依靠使用EXIT语句。但是对于无穷循环，仅可以使用EXIT结束循环的执行。</p>
<h2 id="等待指令">5.3等待指令</h2>
<h3 id="等待一个事件">5.3.1等待一个事件</h3>
<p>如果在调用WAIT时逻辑表达式条件已经为TRUE，则不会停止程序的执行(但是触发提前运行停止)。
如果条件为FALSE，则停止执行程序直到表达式的值为TRUE才继续执行程序。</p>
<h4 id="数字值">数字值</h4>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 36%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th>WAIT FOR...</th>
<th>消息窗口中的消息</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong><span class="math inline">\(IN[5]** | **Waiting for input5**
| **等待直到输入5为TRUE** | | **\)</span>OUT[5]==FALSE</strong></td>
<td><strong>Waiting for not output5</strong></td>
<td><strong>等待直到输入5为FALSE</strong></td>
</tr>
<tr class="even">
<td><strong><span class="math inline">\(TIMER[5]&gt;=300** | **Waiting
until timer5&gt;=300** | **等待直到计时器5至少达到 300ms** | |
**\)</span>TIMER_FLAG[5]</strong></td>
<td><strong>Waiting for Timer_Flag5</strong></td>
<td><strong>等待直到计时器标志5为TRUE</strong></td>
</tr>
<tr class="odd">
<td><strong><span class="math inline">\(FLAG[5]==FALSE** | **Waiting for
not flag5** | **等待直到标志5为FALSE** | |
**\)</span>CYCFLAG[5]</strong></td>
<td><strong>Waiting for cyclical flag5</strong></td>
<td><strong>等待直到循环标志5为TRUE</strong></td>
</tr>
<tr class="even">
<td><strong>I[5]==9</strong></td>
<td><strong>Waiting for counter5==9</strong></td>
<td><strong>等待直到计时器5的值等于 “9</strong></td>
</tr>
</tbody>
</table>
<h4 id="变量值">变量值</h4>
<p>一个变量被转换为一个数字。该变量必须在数据表(<em>.dat)中声明。在源文件(</em>.src)中的声明则是定义该变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据表：            源文件：</span><br><span class="line">DEFDAT PROG1      DEF PROG1( )</span><br><span class="line">…                 …</span><br><span class="line">DECL INT          INT VAR INT VAR=7</span><br><span class="line">…                 …</span><br></pre></td></tr></table></figure>
<p>长文本</p>
<p>信号声明</p>
<h3 id="等待时间">5.3.2 等待时间</h3>
<p><strong>WAIT SEC</strong>语句允许使用秒来编程等待时间：</p>
<h2 id="停止程序">5.4停止程序</h2>
<p><strong>HALT</strong> 如果要中断程序执行和停止处理，编程如下指令</p>
<h2 id="确认消息">5.5 确认消息</h2>
<h1 id="输入输出指令">6 输入输出指令</h1>
<h2 id="一般说明-1">6.1一般说明</h2>
<p>KRC…可以识别1026个输入和1024个输出。在标准的KUKA控制柜中，用户可以使用X11连接器的下列输入和输出（MFC模块）：
输入 1…16</p>
<p>其它输入/输出可以随意配置，例如使用区域总线。
可以读输入和写输出。它们通过系统变量<strong><span
class="math inline">\(IN[No]或\)</span>OUT[No]</strong>寻址。未使用的输出可以当作标记使用。
MFC模块可在文件<strong>“ IOSYS.INI”</strong>重新分配输入/输出。</p>
<h1 id="子程序和函数">7.子程序和函数</h1>
<h2 id="声明">7.1声明</h2>
<h3 id="def">DEF</h3>
<p>所有的子程序与主程序的声明方法一样，使用DEF声明加上名字，以END结束，举例说明：</p>
<h3 id="deffct">DEFFCT</h3>
<p>函数是子程序类型中的一种；不同的是，程序名同时也是一个指定数据类型的变量。函数的结果可以通过简单地给变量分配一个值来传递。因此，当使用关键字DEFFCT声明函数时，函数的数据类型和函数的名字都要指定。函数以ENDFCT指令结束。因为函数假设为传递一个值，所以必须在ENDFCT语句前使用RETURN语句指定该值。例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFFCT INT FUNCTION（）</span><br><span class="line">…</span><br><span class="line">RETURN（X）</span><br><span class="line">ENDFCT  </span><br></pre></td></tr></table></figure>
<h3 id="局部函数">局部函数</h3>
<p>主程序和子程序或函数在同一个SRC文件中。该文件与主程序名相同。</p>
<h3 id="全局函数">全局函数</h3>
<p>全局子程序和函数以单独的SRC文件存储。以该方法，则如果被其它程序调用，则每个调用的程序都变成了子程序</p>
<p>有在主程序的数据表中声明过的变量都可以在子程序和函数中被识别。主程序（SRC文件）中已经声明过的变量称为“
runtime变量”，仅可以在主程序中使用。试图在子程序中使用这些变量会产生相应的错误消息。
主程序中声明过的变量也不能在全局子程序和函数中被识别。
子程序或函数中声明过的变量在主程序中不能被识别。
主程序不能存储其它主程序的局部子程序和函数。
局部子程序/函数名的最大长度是24个字符。全局子程序/函数名的最大长度是20个字符（由于有文件扩展名）。</p>
<h2
id="子程序和函数的调用和参数传递">7.2子程序和函数的调用和参数传递</h2>
<p>通过输入子程序名加上圆括号调用子程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBPROG1（）  </span><br></pre></td></tr></table></figure>
<h3 id="参数表">参数表</h3>
<p><strong>值调用（IN）</strong></p>
<p><strong>参考调用(OUT)</strong></p>
<p>在子程序或函数中通过在参数表的每个变量后输入关键字<strong>IN</strong>输入“通过值调用”。通过输入字<strong>OUT</strong>得到
“通过参考调用”，<strong>OUT</strong>也是缺省设置。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEF CALCULATE（X：OUT，Y：IN，Z：IN，B）  </span><br></pre></td></tr></table></figure>
<p>当传输一个阵列时，在子程序和函数中也必须声明该阵列，但是没有索引。</p>
<h1 id="中断处理">8中断处理</h1>
<p>可能产生中断的原因和系统将对它们采取的措施，必须在中断可以被激活前定义好。
INTERRUPT
使用中断声明完成该操作，给每个中断分配一个优先级、事件和调用的中断程序。完整的语句是：</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 10%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>自变量</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Priority</td>
<td>INT</td>
<td>指定中断优先级的算术表达式，可以使用的优先级为 1…39和81…128。
值40…80为机器人系统的自动优先级分配保留。</td>
</tr>
<tr class="even">
<td>Event</td>
<td>BOOL</td>
<td>定义中断事件的逻辑表达式。下列是允许的： 一个布尔常数 一个布尔变量
一个信号名 一个比较</td>
</tr>
<tr class="odd">
<td>Subprogram</td>
<td></td>
<td>当事件发生时要执行的中断程序的名字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>中断声明是一条指令，因此， 千万不要在声明部分中使用。</p>
</blockquote>
<ul>
<li>一个声明可能在任何时候被另一个声明重写。</li>
<li>GLOBAL中断不同于一般的中断，即使声明的子程序在左边仍然保持有效。</li>
<li>一次最多可以声明32个中断。</li>
<li>在中断条件下不能存储结构变量和成分。</li>
<li>除GLOBAL变量和数据表中声明的变量外，实时变量不能当作中断程序参数被传输。</li>
</ul>
<h2 id="中断的激活">8.2中断的激活</h2>
<h3 id="打开中断">打开中断</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTERRUPT ON 4  开优先级为4的中断  </span><br><span class="line">INTERRUPT ON	开所有中断</span><br></pre></td></tr></table></figure>
<h3 id="边缘触发">边缘触发</h3>
<p>检查是边缘触发型的，也就是说一个中断仅在逻辑条件从FALSE状态变化为TRUE状态时被
触发，反之如果当开中断时条件已经是TRUE则不触发。</p>
<h3 id="关闭中断">关闭中断</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与开的方法相同，中断可以单独或所有一起被关：</span><br><span class="line">INTERRUPT OFF 4</span><br><span class="line">或</span><br><span class="line">INTERRUPT OFF  </span><br></pre></td></tr></table></figure>
<h3 id="禁止使能">禁止/使能</h3>
<p>使用关键字<strong>ENABLE和DISABLE</strong>，已经打开的中断可以被单独或全部使能或禁止。
禁止命令可以在被中断前保护程序的某些部分。一个禁止的中断可以被识别和存储，但是不能被执行。仅当被使能后，已经发生的中断才以它们的优先级顺序被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DISABLE 4</span><br><span class="line">或</span><br><span class="line">DISABLE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>触发一个中断的前提条件是： ●中断必须是声明过的（ INTERRUPT DECL…）
●中断必须被打开（ INTERRUPT ON） ●中断必须是没有被禁止的
●对应的事件必须已经发生（边缘触发）</p>
</blockquote>
<h3 id="优先级">优先级</h3>
<h2 id="停止现在的运动">8.3停止现在的运动</h2>
<p>如果必要的话，
在中断程序中使用BRAKE语句，则可以在中断事件中停止已经正在执行的机器人的运动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRAKE  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>BRAKE 指令仅可以在中断程序中使用，
在其它程序中使用则会导致一个错误引起的停止。</p>
</blockquote>
<h2 id="取消中断事务">8.4取消中断事务</h2>
<p>KRC...中机器人运动的取消是可能的，使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESUME</span><br></pre></td></tr></table></figure>
<p>RESUME可以取消当前中断被声明的级别和以下级别的所有运行的中断程序和子程序。</p>
<blockquote>
<p>同 BRAKE 语句，RESUME 仅允许在中断程序中使用。当激活 RESUME
语句时，提前运行指针千万不要在中断被声明的级别，至少应低一个级别。</p>
</blockquote>
<h2 id="循环标记的使用">8.5循环标记的使用</h2>
<p>在中断声明指令中不允许使用逻辑操作因此，要定义复杂的事件，您必须使用使用程序如下;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$CYCFLAG[3]=$IN[1] AND（[$IN[2] OR $IN[3]）</span><br><span class="line">INTERRUPT DECL 10 WHEN $CYCFLAG[3] DO IR_PROG（）</span><br><span class="line">INTERRUPT ON 10</span><br></pre></td></tr></table></figure>
<p>您可以同时监视和逻辑组合3个输入。</p>
<h1 id="触发轨迹相关的开关动作">9 触发轨迹相关的开关动作</h1>
<h2 id="在轨迹的起点或终点开关动作">9.1在轨迹的起点或终点开关动作</h2>
<h3 id="trigger">TRIGGER</h3>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 9%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>自变量</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Switching point</td>
<td>INT</td>
<td>对于单独的程序段， DISTANCE=0指明为下一个运动
的起点，属性DISTANCE=1则为终点。 对于逼近程序段，
DISTANCE=1表示后续逼近定位圆 弧的中点。如果前一个程序段也
是一个逼近程序段， DISTANCE=0表示前述逼近定位 圆弧的终点。</td>
</tr>
<tr class="even">
<td>Time</td>
<td>INT</td>
<td>使用属性DELAY，可以延迟或提前开关动作某些时 间。
开关点仅可以在有关程序段保持有效时被延迟 或提前。 单位是毫秒。</td>
</tr>
<tr class="odd">
<td>Instruction</td>
<td></td>
<td>指令可以是 一个子程序调用 变量值的分配
一个输出指令（也可以是脉冲）。</td>
</tr>
<tr class="even">
<td>Priority</td>
<td>INT</td>
<td>使用子程序调用的每个TRIGGER语句必须定义一个
优先级。允许值为1...39和81...128。
优先级的使用与中断中的一样。（见章8）。
值40...80为机器人自动优先级分配保留。如果要 使用，编程PRIO=－1。</td>
</tr>
</tbody>
</table>
<h2 id="在轨迹的任何点开关动作">9.2在轨迹的任何点开关动作</h2>
<h3 id="trigger-1">TRIGGER</h3>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 75%" />
</colgroup>
<thead>
<tr class="header">
<th>自变量</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Distance</td>
<td>INT</td>
<td>触发后， 您可以在从编程的终点起指定一个期望的 距离。
如果该终点是一个被逼近的点， 指定开关动作的期
望距离从逼近定位范围中紧靠终点位置算起。 通过指定一个负的距离，
开关点可以最远被移回到 起点。如果该起点是一个逼近定位点，开关点可以
最远被移到逼近定位范围的起点。 通过指定一个正的距离，
则最远移到编程的下一个 精确定位点 单位是毫米。</td>
</tr>
<tr class="even">
<td>Time</td>
<td>INT</td>
<td>使用属性DELAY，可以延迟(+)或提前(-)轨迹中开 关点某些时间。
开关点仅可以在上述给定（最远到下一个精确定位
点）开关范围内被延迟或提前。逼近定位运动中。
开关点至多可以被提前到开始逼近定位的起点。 单位是毫秒。</td>
</tr>
<tr class="odd">
<td>Instruction</td>
<td></td>
<td>指令可以是 一个子程序调用 变量值的分配
一个输出指令（也可以是脉冲）。</td>
</tr>
<tr class="even">
<td>Priority</td>
<td>INT</td>
<td>使用子程序调用的每个TRIGGER语句必须定义一个
优先级。允许值为1...39和81...128。
优先级的使用与中断中的一样。（见章8）。
值40...80为机器人自动优先级分配保留。如果要 使用，编程PRIO=－1。</td>
</tr>
</tbody>
</table>
<h2 id="触发语句重叠">9.3触发语句重叠</h2>
<ul>
<li>手动给两个触发语句分配各自的优先级；</li>
<li>分配两个触发语句的优先级都为“--1”，然后由系统自动分配正确的优先级。</li>
</ul>
<h1 id="数据表">10 数据表</h1>
<h2 id="局部数据表">10.1局部数据表</h2>
<p>数据表用于特殊编程准备和更高级别声明。包含点的消息，例如坐标：
●一个数据表可能为每个SRC文件草拟。数据表与SRC文件具有相同的文件名并以“.DAT”作为扩展名。
●数据表仅可能由声明和初始化组成。 ● 一行由声明和初始化组成。
●不接受系统变量。</p>
<h3 id="defdat">DEFDAT</h3>
<p>在数据表中允许使用下列声明： ● SRC文件中使用子程序和函数的外部声明。
● 导入变量的导入声明。 ● SRC文件中使用变量的声明和初始化。 ●
SRC文件中使用信号和通道名的声明。 ●
数据表或SRC文件中使用数据的声明和列举类型（ Struc，Enum）。</p>
<h2 id="全局数据表">10.2全局数据表</h2>
<p>数据表中定义的变量可被“别的”主程序接受 。</p>
<h3 id="public">PUBLIC</h3>
<p>数据表必须在开头行以关键字PUBLIC定义为“公共可接受”。</p>
<p>如果要使用变量OTTO，从以上数据表PROG_1中导入到PROG_2（），可以在PROG_2（）中编程下列导入声明，与数据表中的关键字PUBLIC一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPORT INT OTTO_2 IS /R1/PROG_1..OTTO</span><br></pre></td></tr></table></figure>
<p>目录/R1下的数据表PROG_1.DAT中的变量OTTO现在是程序PROG_2（）中的OTTO_2</p>
<h3 id="global">GLOBAL</h3>
<p>变量被声明为“全局变量”，例如<code>DECL GLOBAL INTOTTO=0</code>，可不使用导入命令而被所有别的主程序接受。
如果一个全局变量已经被声明，就不能在别的主程序中改变该全局变量名。</p>
<blockquote>
<p>仅允许在数据表中声明全局变量。 如果要在SRC或SUB文件中声明，
则会产生错误消息。</p>
<p>对许多程序有用的长时间有效的、一般意义的变量、结构、通道和信号可以提前定义在$CONFIG.DAT中</p>
</blockquote>
<h1 id="外部编辑器">11外部编辑器</h1>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url">阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="阅读笔记">阅读笔记</h1>
<h2 id="年7月">2022年7月</h2>
<h3
id="基于迁移学习的铣削机器人定位误差补偿方法-邓柯楠">1、基于迁移学习的铣削机器人定位误差补偿方法
邓柯楠</h3>
<p>先建立机器人刚柔耦合误差模型，研究立方体与柱体工作空间内不同区域的误差分布特性；</p>
<p>之后，考虑误差区域相似性将机器人工作空间分为源域空间与目标域空间，在源域空间基于分级采样策略将完备的机器人采样位姿及误差测量数据作为源域数据，对于目标域空间只需要将少量的采样位姿及误差数据作为目标域数据，源域数据与目标域数据均用于训练高斯过程回归模型；</p>
<p>通过基于加权拟合误差的子空间对齐和自适应权重迭代方法提升迁移学习模型预测精度，根据指定机器人位姿参数预测并补偿机器人定位误差；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E5%A4%96%E9%83%A8%E8%BD%AC%E5%8F%B0%E6%A0%87%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E5%A4%96%E9%83%A8%E8%BD%AC%E5%8F%B0%E6%A0%87%E5%AE%9A/" itemprop="url">外部转台标定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="外部轴标定相关参数">外部轴标定相关参数</h1>
<p>1、转台法兰坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=1587.39  Y=1.66  Z=532.22</span><br><span class="line">A=0        B=0     C=0</span><br></pre></td></tr></table></figure>
<p>2、标定参考点坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=1483.29  Y=-118.93  Z=600.94</span><br><span class="line">A=0        B=0     C=0</span><br></pre></td></tr></table></figure>
<p>3、标定点相对于法兰偏置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=-104.1  y=-120.59 z=67.82</span><br></pre></td></tr></table></figure>
<p>4、转台基点坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=1591.965  Y=2.47  Z=-161.551</span><br><span class="line">A=0.024        B=-0.299     C=0.047</span><br></pre></td></tr></table></figure>
<p>5、工件坐标系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=1545.32  Y=-49.85  Z=730.99</span><br><span class="line">A=0      B=0     C=0</span><br></pre></td></tr></table></figure>
<p>6、工件坐标系相对于法兰</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X=-42.013  Y=-51.574  Z=197.818</span><br><span class="line">A=-0.024      B=0.299     C=-0.047</span><br></pre></td></tr></table></figure>
<h1 id="机器人运动链">机器人运动链</h1>
<p><span class="math display">\[
T_{tool}^B=T_Z^B*T_{roz}(\gamma_w)*T_W^Z*T_{tool}^W*T_{roz}(\gamma_r)
\]</span></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/" itemprop="url">实验记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实验记录">实验记录</h1>
<p>2022/7/7</p>
<p>铣削工件材料为尼龙，设置转速为7000rpm，转速为7000rpm时加工效果似乎最佳，进给速度开始使用5mm/s，最后发现太慢了，使用50mm/s的速度进行粗加工。</p>
<p>铣削了简单波浪形曲面，粗加工未成功，加工过程中出现了预期之外的轨迹，且最后直接插进了尼龙块中，最终停止了加工，未完成加工。</p>
<p>下一步：检查一下轨迹是否正确，通过运动学仿真和空走进行验证。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E5%86%97%E4%BD%99%E3%80%81%E5%B7%A5%E4%BB%B6%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E5%86%97%E4%BD%99%E3%80%81%E5%B7%A5%E4%BB%B6%E4%BC%98%E5%8C%96/" itemprop="url">参数优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一冗余自由度">一、冗余自由度</h1>
<p>刀具路径由离散的CLS数据组成， <span class="math display">\[
CLS=(x,y,z,i,j,k)
\]</span>
其中<strong>x,y,z</strong>为刀具位置，<strong>i,j,k</strong>为刀轴方向的单位向量</p>
<h2 id="cls对应的末端姿态">1、CLS对应的末端姿态</h2>
<h3 id="方法一">方法一：</h3>
<p>引用文献中的方法</p>
<blockquote>
<p>Peng J, Ding Y, Zhang G, 等. Smoothness-oriented path optimization
for robotic milling processes[J]. Science China Technological Sciences,
2020, 63(9): 1751–1763.</p>
</blockquote>
<p>由cls可以生成刀具姿态，但是刀具姿态并不唯一，定义初始机器人任务姿态为：</p>
<p><span
class="math inline">\(o_i=(x,y,z)\)</span>为刀具姿态矩阵的位置，z轴向量为
<span class="math display">\[
z_i = （i，j，k）
\]</span> x轴向量为 <span class="math display">\[
x_i=y_i \times z_i
\]</span> y轴向量可以有下式计算得来 <span class="math display">\[
y_i= \frac{z_i \times \overline{o_{i+1} o_{i}} } {\lVert {z_i \times
\overline{o_{i+1} o_{i}}} \lVert}\\
对于最后一个cls点\\
y_i= \frac{z_i \times \overline{o_{i-1} o_{i}} } {\lVert {z_i \times
\overline{o_{i-1} o_{i}}} \lVert}\\
\]</span>
由此可以得到机器人末端初始姿态矩阵，因为绕刀具轴的旋转对铣刀定位没有影响，因此对于一个CLS，存在无数的可行机器人姿态，可由绕刀轴旋转得到。
<span class="math display">\[
T(\gamma_i) = T_i \cdot Rot(\hat{z},\gamma_i)\\
T_i = \begin{bmatrix}
x_i&amp;y_i&amp;z_i&amp;o_i\\
0&amp;0&amp;0&amp;1\end {bmatrix}\\
\]</span> 其中<span
class="math inline">\(T_i\)</span>为cls对应的初始末端矩阵，<span
class="math inline">\(\gamma \in
[-\pi,\pi]\)</span>为冗余自由度，这样就可以得到CLS任意冗余自由度对应的末端姿态矩阵。</p>
<blockquote>
<p>这种方法会导致刀具轨迹弯折时机器人姿态变化较大</p>
</blockquote>
<h3 id="方法二">方法二：</h3>
<blockquote>
<p>[1]Zhu W, Qu W, Cao L, 等. An off-line programming system for robotic
drilling in aerospace manufacturing[J]. The International Journal of
Advanced Manufacturing Technology, 2013, 68(9–12): 2535–2545.</p>
</blockquote>
<p>定义与上一个的方法一样，<span class="math inline">\(z_i =
[i,j,k]\)</span>，而<span
class="math inline">\(x_i\)</span>是三个标准单位向量<span
class="math inline">\([1,0,0],[0,1,0],[0,0,1]\)</span>在由<span
class="math inline">\([x,y,z]和[i,j,k]\)</span>决定的平面上的最长投影的归一化向量，<span
class="math inline">\(y_i\)</span>是<span
class="math inline">\(z_i\)</span>和<span
class="math inline">\(x_i\)</span>的叉积。</p>
<h3 id="方法三">方法三:</h3>
<blockquote>
<p>[1]熊刚. 机器人铣削加工的误差补偿和力控制方法研究[D]. 上海交通大学,
2019.</p>
</blockquote>
<img src="/2022/08/24/%E5%86%97%E4%BD%99%E3%80%81%E5%B7%A5%E4%BB%B6%E4%BC%98%E5%8C%96/image-20220513120231244.png" class="" title="image-20220513120231244">
<h3 id="方法四">方法四：</h3>
<p>计算刀轴向量和 基座标系Z轴之间的变换矩阵</p>
<p>将两个向量之间的变换视为绕某一轴的旋转某一角度的螺旋运动，旋转角为两个向量之间的夹角，而旋转轴则是两个向量之间的叉积。</p>
<p>已知单位向量，将其绕某一轴<span
class="math inline">\(\omega\)</span>旋转<span
class="math inline">\(\theta\)</span>，通过使用<strong>罗德里格斯公式</strong>可以计算其旋转矩阵。
<span class="math display">\[
R(\omega,\theta) =I +sin\theta[\omega]+(1-cos\theta)[\omega]^2
\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="comment">#使用轴角法求取向量之间的变换矩阵，和上一个函数是一样的方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotation_matrix_from_vectors2</span>(<span class="params">vec2</span>):</span><br><span class="line">    vec1 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="comment">#规范化两个向量</span></span><br><span class="line">    a, b = (vec1 / np.linalg.norm(vec1)).reshape(<span class="number">3</span>), (vec2 / np.linalg.norm(vec2)).reshape(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#求两个向量变换的旋转轴</span></span><br><span class="line">    v = np.cross(a, b)</span><br><span class="line">    s = np.linalg.norm(v)</span><br><span class="line">    v = v / s</span><br><span class="line">    <span class="comment">#求旋转角度</span></span><br><span class="line">    c = np.dot(a, b)</span><br><span class="line">    theta = math.acos(c)</span><br><span class="line">    <span class="comment">#使用mr库求取轴角法的旋转矩阵，用的是罗德里格斯公式</span></span><br><span class="line">    omegaHat = mr.VecToso3(v)</span><br><span class="line">    so3mat = omegaHat * theta</span><br><span class="line">    matrix = mr.MatrixExp3(so3mat)</span><br><span class="line">    <span class="comment">#求矩阵对应的欧拉角</span></span><br><span class="line">    r = R.from_matrix(matrix)</span><br><span class="line">    euler = r.as_euler(<span class="string">&#x27;ZYX&#x27;</span>,degrees=<span class="literal">True</span>)</span><br><span class="line">    matrix = r.as_matrix()</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line">方法二：本质上都是一样的</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rotation_matrix_from_vectors</span>(<span class="params">vec1,vec2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Find the rotation matrix that aligns vec1 to vec2</span></span><br><span class="line"><span class="string">    :param vec1: A 3d &quot;source&quot; vector</span></span><br><span class="line"><span class="string">    :param vec2: A 3d &quot;destination&quot; vector</span></span><br><span class="line"><span class="string">    :return mat: A transform matrix (3x3) which when applied to vec1, aligns it with vec2.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    a, b = (vec1 / np.linalg.norm(vec1)).reshape(<span class="number">3</span>), (vec2 / np.linalg.norm(vec2)).reshape(<span class="number">3</span>)</span><br><span class="line">    v = np.cross(a, b)</span><br><span class="line">    c = np.dot(a, b)</span><br><span class="line">    s = np.linalg.norm(v)</span><br><span class="line">    kmat = np.array([[<span class="number">0</span>, -v[<span class="number">2</span>], v[<span class="number">1</span>]], [v[<span class="number">2</span>], <span class="number">0</span>, -v[<span class="number">0</span>]], [-v[<span class="number">1</span>], v[<span class="number">0</span>], <span class="number">0</span>]])</span><br><span class="line">    rotation_matrix = np.eye(<span class="number">3</span>) + kmat + kmat.dot(kmat) * ((<span class="number">1</span> - c) / (s ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> rotation_matrix</span><br></pre></td></tr></table></figure>
<h2 id="末端姿态对应的欧拉角">2、末端姿态对应的欧拉角</h2>
<p>末端到基座标的旋转角ABC，是绕动坐标系旋转的ZYX欧拉角，KRC中定义角度A、B和C是绕Z、Y和X的旋转角度，旋转顺序也必须遵从：</p>
<ol type="1">
<li>绕Z轴旋转角度为A</li>
<li>绕Y轴旋转角度为B</li>
<li>绕X轴旋转角度为C</li>
</ol>
<img src="/2022/08/24/%E5%86%97%E4%BD%99%E3%80%81%E5%B7%A5%E4%BB%B6%E4%BC%98%E5%8C%96/image-20220504214148968-16516717171351.png" class="" title="image-20220504214148968">
<p>由机器人导论中的方法，对旋转矩阵求逆解 <span class="math display">\[
R_{ZYX}=R_Z(\alpha)R_Y(\beta)R_X(\gamma)=\begin {bmatrix} r11 &amp; r12
&amp;r13\\
r21&amp;r22&amp;r23\\
r31&amp;r32&amp;r33\end {bmatrix}\\
\beta=Atan2(-r_{31},\sqrt{r_{11}^2 + r_{21}^2})\\
\alpha=Atan2(\frac {r_{21}}{c\beta},\frac {r_{11}}{c\beta})\\
\gamma = Atan2(\frac{r_{32}}{c\beta},\frac {r_{33}}{c\beta})
\]</span> 虽然存在第二个解，但是在上式中取<span
class="math inline">\(\beta\)</span>的正根以得到单解，满足<span
class="math inline">\(-90\le \beta \le
90\)</span>，以此获取各种姿态表示法之间一一对应的映射函数。如果等于+-90，解的结果就退化了，这个时候一般取<span
class="math inline">\(\alpha = 0\)</span>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/" itemprop="url">谱聚类算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>谱聚类算法</strong>：谱指的是某个矩阵的<strong>特征值</strong>。</p>
<p>谱聚类的思想来源于图论，它把待聚类的数据集中的每一个样本看做是图中一个<strong>顶点</strong>，这些顶点连接在一起，连接的这些<strong>边上有权重</strong>，<strong>权重的大小</strong>表示这些样本之间的<strong>相似程度</strong>。<strong>同一类</strong>的顶点它们的<strong>相似程度很高</strong>，在图论中体现为同一类的顶点中连接它们的边的<strong>权重很大</strong>；<strong>不在同一类</strong>的顶点连接它们的边的<strong>权重很小</strong>。于是谱聚类的<strong>最终目标</strong>就是找到一种<strong>切割图的方法</strong>，使得切割之后的各个子<strong>图内的权重很大</strong>，<strong>子图之间的权重很小</strong>。</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/202203111026750.jpg" class="" title="img">
<h1 id="一预备知识">一、预备知识</h1>
<ul>
<li><p>假设给定一个数据集<span class="math inline">\(X=\{
x_1,x_2,...,x_n
\}\)</span>，我们将这个n个数据向量当做m维空间中某一幅无向图上的一个个点，目的是衡量这些点的相似性。</p></li>
<li><p>把图叫做相似图，记为<span
class="math inline">\(G=(V,E)\)</span>，其中<span
class="math inline">\(V=\{ v_1,v_2...,v_n \}\)</span>表示顶点，<span
class="math inline">\(E\)</span>表示边的集合。两个顶点<span
class="math inline">\(v_i,v_j\)</span>的边的权重记为<span
class="math inline">\(\omega_{ij}\)</span></p></li>
<li><p>相似性用<span
class="math inline">\(s_{ij}\)</span>表示，越大表示越相似</p></li>
<li><p>n个权重点构成一个矩阵<span
class="math inline">\(W=(\omega_{ij})\)</span></p></li>
</ul>
<h2
id="邻接矩阵度和度矩阵连通子图">1.1<strong>邻接矩阵、度和度矩阵、连通子图</strong></h2>
<h3 id="邻接矩阵">（1）邻接矩阵</h3>
<p>所有顶点之间的权重构成一个矩阵，叫<strong>邻接矩阵</strong>，也叫<strong>权重矩阵</strong>。两个顶点互相之间的权重是一样的，因此<span
class="math inline">\(W\)</span>是对称矩阵。</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220311114622575.png" class="" title="image-20220311114622575">
<h3 id="度矩阵">（2）度矩阵</h3>
<p>对于某个顶点的<strong>度</strong><span
class="math inline">\(d_i,i=1,2,...,n\)</span>，定义为</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220311115316683.png" class="" title="image-20220311115316683">
<p>度其实就是邻接矩阵的第<span
class="math inline">\(i\)</span>行的和。（因为邻接矩阵是对称矩阵，所以第<span
class="math inline">\(j\)</span>列的和也可以）</p>
<p><strong>度矩阵</strong>定义为<span
class="math inline">\(n\)</span>个度构成的<strong>对角矩阵</strong>：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220311115709665.png" class="" title="image-20220311115709665">
<p>对于给定顶点<span class="math inline">\(V\)</span>的一个子集<span
class="math inline">\(A\subset V\)</span>，定义它的补为<span
class="math inline">\(\bar{A}\)</span>。对于某个顶点<span
class="math inline">\(v_i \in A\)</span>，定义对应的指示向量为<span
class="math inline">\(1_A = [f_1,f_2...,f_n]^T \in R^n\)</span>，若<span
class="math inline">\(v_i \in
A\)</span>，则<strong>指示向量</strong>第i个位置为1，即<span
class="math inline">\(f_i =
1\)</span>，否则为0；对于两个子集A和B，我们定义：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220311132125530.png" class="" title="image-20220311132125530">
<p>公式(4)表示两个子集中顶点之间的权重之和，<strong>注意这里不包含子集内顶点之间的权重</strong>。</p>
<p><strong>子集大小</strong>有两种定义</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220311132240644.png" class="" title="image-20220311132240644">
<h3 id="连通子图">（3）连通子图</h3>
<p>如果<span
class="math inline">\(A\)</span>中的任意两个顶点都至少存在一条路径将他们连接起来，并且<span
class="math inline">\(A\)</span>中其他顶点也在这条路径上，则<span
class="math inline">\(A\)</span>是<strong>连接</strong>的。如果子集<span
class="math inline">\(A\)</span>是连接的，并且与他的补<span
class="math inline">\(\bar{A}\)</span>不存在任何的连接，则称为<strong>连通子图</strong>。非空子集<span
class="math inline">\(A_1,A_2,...,A_k\)</span>构成<span
class="math inline">\(V\)</span>的一个<strong>分割</strong>，即<span
class="math inline">\(A_1\cup A_2 \cup... \cup A_k=V\)</span></p>
<h2 id="相似图的衡量方法">1.2 相似图的衡量方法</h2>
<p>如果度量空间具有距离越远越不相似，越近越相似的特性，通常作为<strong>相似度</strong>的衡量标准。</p>
<h3 id="近邻法">（1）$ - 近邻法 $</h3>
<p>采用欧式距离计算两个顶点的距离<span
class="math inline">\(s_{ij}\)</span>，然后设定一个阈值<span
class="math inline">\(\epsilon\)</span></p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312185718753.png" class="" title="image-20220312185718753">
<h3 id="k-邻近法">（2）k-邻近法</h3>
<p>利用<strong>KNN算法</strong>遍历所有的样本点，取每个样本最近的k个点作为近邻，取与顶点最近的<span
class="math inline">\(k\)</span>个顶点，该顶点与<span
class="math inline">\(k\)</span>个顶点的权重都大于0。但是这种方法不能保证相似矩阵是对称的，因为两个顶点可能不是在互相的近邻中。一般使用两种方法保证相似矩阵的对称。</p>
<ul>
<li>两个顶点只要其中一个点在另一个顶点的近邻中，则令<span
class="math inline">\(\omega_{ij}=\omega_{ji}\)</span></li>
</ul>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312190301385.png" class="" title="image-20220312190301385">
<ul>
<li>两个顶点同时在双方的近邻中，则令<span
class="math inline">\(\omega_{ij}=\omega_{ji}\)</span>​，否则<span
class="math inline">\(\omega_{ij}=\omega_{ji}=0\)</span></li>
</ul>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312190424470.png" class="" title="image-20220312190424470">
<h3 id="全连接法">（3）全连接法</h3>
<p>该方法将所有的顶点都连接起来。然后通过度量空间中某种对称度量算子来计算顶点之间的相似度。常用的有<strong>多项式核函数，高斯核函数和Sigmoid核函数</strong>。最常用的是高斯核函数RBF，此时相似矩阵和邻接矩阵相同，比如使用<strong>高斯核函数</strong>计算两个顶点之间的相似度：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312190629703.png" class="" title="image-20220312190629703">
<p>实际应用中，使用<strong>全连接法</strong>是最普遍的，而在全连接法中使用<strong>高斯径向核RBF</strong>是最普遍的。</p>
<h2 id="图拉普拉斯矩阵">1.3 图拉普拉斯矩阵</h2>
<h3 id="非规范化的图拉普拉斯矩阵">1.3.1 非规范化的图拉普拉斯矩阵</h3>
<p>图拉普拉斯矩阵的定义如下：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312200714522.png" class="" title="image-20220312200714522">
<p>其中<span
class="math inline">\(D\)</span>为度矩阵，W为权重（近似）矩阵，所以L也是对称矩阵</p>
<p><strong>性质：</strong></p>
<ul>
<li>对于任意向量$f R^n $</li>
</ul>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312201051146.png" class="" title="image-20220312201051146">
<ul>
<li><p><span
class="math inline">\(L\)</span>是一个<strong>对称半正定矩阵</strong>。</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312201216584.png" class="" title="image-20220312201216584"></li>
<li><p><span
class="math inline">\(L\)</span>的最小特征值为0，对应的特征向量是全为1的向量<span
class="math inline">\(1\)</span>。<span class="math inline">\(0 \le
\lambda_1 \le \lambda_2 ...\le \lambda_n\)</span></p></li>
<li><p>对于一个对角分块矩阵<span class="math inline">\(A\)</span></p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312201648665.png" class="" title="image-20220312201648665">
<p>他的特征值等于各个分块矩阵的特征值。</p></li>
<li><p>若<span
class="math inline">\(G\)</span>是一个具有非负权重的无向图，则它对应的图拉普拉斯矩阵L的0<strong>特征值的代数重数</strong>k等于G中<strong>连通子图的个数</strong>，假设k个连通子图记为<span
class="math inline">\(A_1,A_2,...A_k\)</span>，并且0特征值对应的特征值空间由各个连通子图的指示向量<span
class="math inline">\(1_{A_i} \in R_n\)</span>。</p></li>
</ul>
<h3 id="规范化的图拉普拉斯矩阵">1.3.2规范化的图拉普拉斯矩阵</h3>
<p>有两种规范化的图拉普拉斯矩阵，他们互相联系。这两种规划化的图拉普拉斯矩阵定义为：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312205724786.png" class="" title="image-20220312205724786">
<p>公式(19)中的<span
class="math inline">\(L_{sym}\)</span>是一个对称矩阵，下标sym是单词symmetric的简写，<span
class="math inline">\(L_{rw}\)</span>不是对称矩阵，该矩阵和随机游走(random
walk)相关，下标rw就是random walk 的首字母组合。</p>
<p><span class="math inline">\(L_{sym}\)</span>的性质:</p>
<ul>
<li>对于任意向量<span class="math inline">\(f \in R^n\)</span></li>
</ul>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312205922264.png" class="" title="image-20220312205922264">
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312205930303.png" class="" title="image-20220312205930303">
<ul>
<li><p><span class="math inline">\(L_{sym}\)</span>和<span
class="math inline">\(L_{rw}\)</span>具有相同的特征值，对应的特征值向量关系为
<span class="math display">\[
\omega = D^{1/2} u
\]</span></p></li>
<li></li>
</ul>
<h1 id="二切割方法">二、切割方法</h1>
<p>优化的目标函数为：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312210846810.png" class="" title="image-20220312210846810">
<h2 id="ratiocut切图">2.1 RatioCut切图</h2>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312211959073.png" class="" title="image-20220312211959073">
<p>引入指示向量<span
class="math inline">\(h_j∈{h_1,h_2,..h_k},j=1,2,...k,\)</span>对于任意一个向量<span
class="math inline">\(h_j\)</span>,
它是一个n维向量（n为样本数），我们定义</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312212210088.png" class="" title="image-20220312212210088">
<p>对应的<strong>RatioCut函数表达式</strong>为：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312212238622.png" class="" title="image-20220312212238622">
<p>松弛化的目标函数：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213754655.png" class="" title="image-20220312213754655">
<p>将图切割为k个分组的问题转换成了求图拉普拉斯矩阵L的<strong>前k个最小特征值对应的特征向量<span
class="math inline">\(h_j∈{h_1,h_2,..h_k},j=1,2,...k,\)</span></strong>和L二次型之和。</p>
<p>求出来的<span
class="math inline">\(h_i\)</span>并不能准确指示顶点所属类别，将矩阵<span
class="math inline">\(H=
[h_1,h_2,..h_k]\)</span>当作一个新的具有k个维度特征n个样本的数据集进行<span
class="math inline">\(k-means\)</span>聚类。是对每一个样本聚类，聚类的类别数是k,也就是对H的每一行进行聚类。</p>
<h2 id="ncut切图">2.2 Ncut切图</h2>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213256066.png" class="" title="image-20220312213256066">
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213419592.png" class="" title="image-20220312213419592">
<p>优化目标任然是</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213433072.png" class="" title="image-20220312213433072">
<p>松弛化的目标函数：</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213820132.png" class="" title="image-20220312213820132">
<p>令<span class="math inline">\(B= D^{1/2}H\)</span>:</p>
<img src="/2022/08/24/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/image-20220312213915761.png" class="" title="image-20220312213915761">
<p>上式的解<span class="math inline">\(B^*\)</span>也就是矩阵<span
class="math inline">\(L_{sym}\)</span>的前k个最小特征值对应的特征向量按列排列成<span
class="math inline">\(B^* = \{ b_1,b_2,...,b_k
\}\)</span>。反带入可得<span
class="math inline">\(L_{rw}\)</span>前k个最小特征值对应的特征向量<span
class="math inline">\(H=\{h_1,h_2,..h_k\}\)</span></p>
<p>或者矩阵<span class="math inline">\(L\)</span>的前<span
class="math inline">\(k\)</span>个最小的广义特征值对应的特征向量。</p>
<h1 id="三算法实现步骤">三、算法实现步骤</h1>
<p>最常用的相似矩阵的生成方式是基于<strong>高斯核距离</strong>的全连接方式，最常用的<strong>切图方式是Ncut</strong>。而到最后常用的<strong>聚类方法为K-Means</strong>。</p>
<p>假设聚成<span class="math inline">\(k\)</span>个分组</p>
<p>（1）计算相似度矩阵<span class="math inline">\(W\)</span></p>
<p>（2）计算度矩阵<span class="math inline">\(D\)</span></p>
<p>（3）计算图拉普拉斯矩阵<span
class="math inline">\(L\)</span>，构建标准化后的图拉普拉斯矩阵<span
class="math inline">\(D^{-1/2}LD^{-1/2}\)</span></p>
<p>（4）直接对<span
class="math inline">\(D^{-1/2}LD^{-1/2}\)</span>进行特征值分解，获取其前<span
class="math inline">\(k\)</span>个特征值对应的特征向量按照列排成矩阵<span
class="math inline">\(Q=[q_1,q_2,...,q_k]\)</span></p>
<p>（5）对矩阵<span class="math inline">\(Q\)</span>的 所有行<span
class="math inline">\(r_1,r_2,...r_n\)</span>标准化，组成<span
class="math inline">\(n*k\)</span>进行聚类，如使用<span
class="math inline">\(k-means\)</span>方法或者别的方法进行聚类得到<span
class="math inline">\(C_1,C_2,...,C_k\)</span></p>
<p>（6）输出原始数据的分组<span
class="math inline">\(A_1,A_2,...,A_k\)</span>，其中<span
class="math inline">\(A_i=\{v_j|r_j \in C_i \}\)</span></p>
<p>注意：在第(4)步也可以再计算规范化的矩阵<span
class="math inline">\(L_{sym}\)</span>，在对这个矩阵做特征分解或者做广义特征值分解，后面步骤相同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/" itemprop="url">机器人学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一机器人学">一、机器人学</h1>
<h2 id="poe">1.POE</h2>
<p>（1）</p>
<p>（2）</p>
<h3 id="刚体运动">（3）刚体运动</h3>
<h4 id="旋转与角速度">3.1旋转与角速度</h4>
<h5 id="旋转矩阵">1.旋转矩阵</h5>
<p><span class="math display">\[
R=Rot(\hat{\omega},\theta)
\]</span></p>
<p>满足以下条件</p>
<ul>
<li>正则条件</li>
<li>正交条件</li>
<li>坐标系三个坐标轴遵循右手定则</li>
</ul>
<p>3*3旋转矩阵组成的集合被称为<strong>特殊正交群SO(3)</strong></p>
<p><strong>特性</strong></p>
<ul>
<li>封闭性</li>
<li>结合律</li>
<li>幺元性</li>
<li>可逆性</li>
</ul>
<p><strong>用途</strong></p>
<ol type="1">
<li>表示姿态</li>
<li>进行坐标系转换</li>
<li>对向量和坐标系进行旋转变换</li>
</ol>
<p><strong>左乘</strong>旋转矩阵会得到绕固定坐标系中的转轴转动，<strong>右乘</strong>会得到绕<strong>物体坐标系</strong>中转轴的转动。</p>
<h5 id="角速度">2.角速度</h5>
<p><span class="math display">\[
\omega=\hat{\omega}\dot{\theta}
\]</span></p>
<p><strong>反对称矩阵</strong></p>
<p>在<strong>空间坐标系中的角速度</strong></p>
<p><strong>物体坐标系下的角速度</strong> <span class="math display">\[
[\omega_b]=R^{-1}\dot{R}
\]</span> <span class="math inline">\(\omega \in
R^3\)</span>是角速度的向量表达形式，<span
class="math inline">\([\omega]\in so(3)\)</span>是3*3矩阵表示形式。</p>
<h5 id="转动的指数坐标表示">3.转动的指数坐标表示</h5>
<p><strong>转动的三参数指数坐标</strong></p>
<p>向量<span class="math inline">\(\dot\omega \theta \in
R^3\)</span>就是转动的三参数指数坐标形式，单独写就是<strong>转动的轴-角表示法</strong></p>
<p><strong>刚体转动的指数坐标</strong></p>
<p><strong>刚体转动的矩阵对数</strong></p>
<p>若<span class="math inline">\(\dot\omega \theta \in
R^3\)</span>表示旋转矩阵R的指数坐标，那么反对称矩阵<span
class="math inline">\([\hat{\omega }\theta]=[\hat{\omega }]\theta \in
so(3)\)</span>就是矩阵R的矩阵对数。矩阵对数是矩阵指数的可逆形式。正像矩阵指数是矩阵形式的角速度<span
class="math inline">\([\hat{\omega }]\theta \in
so(3)\)</span>在单位时间（ 1秒）内的定积分，使刚体运动到给定姿态<span
class="math inline">\(R\in
SO(3)\)</span>—样，矩阵对数则是对R进行微分，以找到一个常值角速度<span
class="math inline">\([\hat{\omega }]\theta \in
so(3)\)</span>的矩阵表示形式。</p>
<h4 id="刚体运动与运动旋量">3.2刚体运动与运动旋量</h4>
<p><strong>齐次变换矩阵T</strong>与旋转矩阵R相对应，螺旋轴S与旋转轴<span
class="math inline">\(\hat\omega\)</span>相对应，运动旋量V(可表示成<span
class="math inline">\(S\dot\theta\)</span>）与角速度<span
class="math inline">\([\hat{\omega }\theta]=[\hat{\omega }]\theta \in
so(3)\)</span>相对应，而用于描述刚体位移的指数坐标<span
class="math inline">\(S\theta \in R^6\)</span>与刚体转动的指数坐标<span
class="math inline">\(\hat \omega \theta \in R^3\)</span>相对应。</p>
<p><strong>特殊欧氏群SE(3)</strong>亦称刚体运动群或齐次变换矩阵群，是所有4×4实矩阵T的集合
。</p>
<h5 id="运动旋量">运动旋量</h5>
<p>将<span
class="math inline">\(\omega_b、v_b\)</span>合在一起组成一个六维向量形式。为此定义为物体坐标系中的速度，简称为物体运动旋量。</p>
<p>如前所述，角速度可以很方便的写成反对称矩阵形式，同样，运动旋量也能写成矩阵形式。</p>
<p>同样，基于空间坐标系，写出<strong>空间运动旋量</strong></p>
<p><strong>物体运动旋量和空间运动旋量的关系</strong></p>
<h5 id="运动旋量的螺旋释义">运动旋量的螺旋释义</h5>
<p>运动旋量<span class="math inline">\(V\)</span>也可以写成螺旋轴<span
class="math inline">\(S\)</span>与绕该轴转动的速度<span
class="math inline">\(\dot\theta\)</span>组合形式</p>
<p><span class="math inline">\(S=(\omega,v)\)</span>的矩阵表达式为</p>
<h4 id="刚体运动的指数坐标表达">3.3刚体运动的指数坐标表达</h4>
<p>Chasles_Mozzi定理:任何刚体运动都可通过绕空间某—固定螺旋轴S的运动来实现
。</p>
<p>类似转动情况，定义矩阵指数和矩阵对数</p>
<p>将<strong>矩阵指数</strong>进行级数展开</p>
<p><strong>矩阵对数</strong></p>
<h4 id="力旋量">3.4力旋量</h4>
<p>将力矩与力合成为—个六维的空间力（spatial
lOrce）,称为力旋量（wrench）。</p>
<h4 id="函数">3.5函数</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1.计算旋转矩阵的逆</span><br><span class="line">invR = RotInv(R)</span><br><span class="line"></span><br><span class="line">2.将三维向量转换为3*3反对称矩阵</span><br><span class="line">so3mat = VecToso3(omg)</span><br><span class="line"></span><br><span class="line">3.将3*3反对称矩阵转换为三维向量</span><br><span class="line">omg = so3ToVec(so3mat)</span><br><span class="line"></span><br><span class="line">4.从旋转的三维指数坐标中提取出轴线和角度</span><br><span class="line">[omghat,theta] = AxisAng3(expc3)</span><br><span class="line"></span><br><span class="line">5.计算矩阵指数对应的旋转矩阵</span><br><span class="line">R = MatrixExp3(so3mat)</span><br><span class="line"></span><br><span class="line">6.计算旋转矩阵对应的矩阵对数</span><br><span class="line">so3mat = MatrixLog3(R)</span><br><span class="line"></span><br><span class="line">7.M到SO（3）旋转矩阵的空间距离的度量</span><br><span class="line">d = DistanceToSO3(mat)</span><br><span class="line"></span><br><span class="line">8.判断M是否为旋转矩阵</span><br><span class="line">judge = TestIfSO3(mat)</span><br><span class="line"></span><br><span class="line">9.返回与M最近的旋转矩阵</span><br><span class="line">R = ProjectToSO3(mat)</span><br><span class="line"></span><br><span class="line">10.</span><br><span class="line">T = RpToTrans(R,p)</span><br><span class="line"></span><br><span class="line">11.从变换矩阵中分离出旋转矩阵和位置向量</span><br><span class="line">[R,p] = TransToRp(T)</span><br><span class="line"></span><br><span class="line">12.变换矩阵求逆</span><br><span class="line">invT = TransInv(T)</span><br><span class="line"></span><br><span class="line">13.构造与六维向量形式的运动旋量V对应的</span><br><span class="line">se3mat = VecTose3(V)</span><br><span class="line"></span><br><span class="line">14.构造与se(3)矩阵对应的六维向量形式的运动旋量V</span><br><span class="line">V = se3ToVec(se3mat)</span><br><span class="line"></span><br><span class="line">15.计算变换矩阵T的6*6的伴随矩阵</span><br><span class="line">AdT = Adjoint(T)</span><br><span class="line"></span><br><span class="line">16.返回正则化的螺旋轴表达式</span><br><span class="line">S = ScrewToAxis(q,s,h)</span><br><span class="line"></span><br><span class="line">17.从六位向量形式的指数坐标中提取出螺旋轴和沿轴线移动的距离</span><br><span class="line">[S,theta] = AxisAng6(expc6)</span><br><span class="line"></span><br><span class="line">18.计算矩阵指数对应的变换矩阵</span><br><span class="line">T = MatrixExp6(se3mat)</span><br><span class="line"></span><br><span class="line">19.计算变换矩阵对应的矩阵对数</span><br><span class="line">se3mat = MatrixLog6(T)</span><br><span class="line"></span><br><span class="line">20.M到变换矩阵的空间距离</span><br><span class="line">d = DistanceToSE3(mat)</span><br><span class="line"></span><br><span class="line">21.判断是否为SE3变换矩阵</span><br><span class="line">judge = TestIfSE3(mat)</span><br><span class="line"></span><br><span class="line">22.离M最近的变换矩阵</span><br><span class="line">T = ProjectToSE3(mat)</span><br></pre></td></tr></table></figure>
<h3 id="正向运动学">（4）正向运动学</h3>
<h4 id="指数积公式">4.1指数积公式</h4>
<p>现在假定关节<span
class="math inline">\(n\)</span>对应的关节变量为<span
class="math inline">\(\theta\)</span>末端坐标系<span
class="math inline">\(M\)</span>的位移可写成</p>
<p>式中，<span class="math inline">\(T \in
SO(3)\)</span>为末端的新位形’，<span
class="math inline">\(S=(\omega_n，v_n)\)</span>为表示在基坐标系中的关节<span
class="math inline">\(n\)</span>的旋量坐标。若关节<span
class="math inline">\(n\)</span>是转动副（对应的是零节距的螺旋运动），则叫<span
class="math inline">\(\omega_n \in
R^3\)</span>是沿关节轴正向的单位向量，<span
class="math inline">\(v_n=-\omega_n\times q_n\)</span>，<span
class="math inline">\(q_n\)</span>为关节轴上任一点，坐标值在基坐标系中进行度量。若关节<span
class="math inline">\(n\)</span> 是移动副，则叫<span
class="math inline">\(\omega_n=0 ，v_n\in
R^3\)</span>是沿关节轴正向的单位向量，<span
class="math inline">\(\theta_n\)</span>表示移动的距离。</p>
<p>上述方程就是指数积公式的<strong>空间坐标表达形式</strong></p>
<p>同样也可以导出<strong>物体坐标系的指数积公式</strong></p>
<h4 id="函数-1">4.2函数</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">末端坐标系下。给定初始形位，关节旋量以及关节值，计算末端坐标系</span><br><span class="line">T = FKinBody(M,Blist,thetalist)</span><br><span class="line">空间坐标系下。给定初始形位，关节旋量以及关节值，计算末端坐标系</span><br><span class="line">T = FKinSpace(M,Slist,thetalist)</span><br></pre></td></tr></table></figure>
<h4 id="库卡kr60-3运动学建模">4.3库卡KR60-3运动学建模</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> modern_robotics <span class="keyword">as</span> mr</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">omega_1 = np.array([<span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>])</span><br><span class="line">omega_2=np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">omega_3=np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">omega_4=np.array([-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">omega_5=np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">omega_6=np.array([-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">q1=np.array([<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line">q2=np.array([<span class="number">350</span>,<span class="number">0</span>,<span class="number">815</span>])</span><br><span class="line">q3=np.array([<span class="number">1200</span>,<span class="number">0</span>,<span class="number">815</span>])</span><br><span class="line">q4=np.array([<span class="number">2020</span>,<span class="number">0</span>,<span class="number">960</span>])</span><br><span class="line">q5=np.array([<span class="number">2020</span>,<span class="number">0</span>,<span class="number">960</span>])</span><br><span class="line">q6=np.array([<span class="number">2020</span>,<span class="number">0</span>,<span class="number">960</span>])</span><br><span class="line"></span><br><span class="line">M=np.array([[ <span class="number">0</span>,    <span class="number">0</span>,    <span class="number">1</span>,  <span class="number">2190</span>],</span><br><span class="line">            [ <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">0</span>,     <span class="number">0</span>],</span><br><span class="line">            [-<span class="number">1</span>,    <span class="number">0</span>,    <span class="number">0</span>,   <span class="number">960</span>],</span><br><span class="line">            [ <span class="number">0</span>,    <span class="number">0</span>,    <span class="number">0</span>,     <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># thetalist = np.array([0,-pi/2,pi/2,0,0,0])</span></span><br><span class="line">thetalist = np.array([-<span class="number">2.410000</span> / <span class="number">180</span> * pi, -<span class="number">57.230000</span> / <span class="number">180</span> * pi, <span class="number">112.080000</span> / <span class="number">180</span> * pi, -<span class="number">0.780000</span> / <span class="number">180</span> * pi, -<span class="number">54.890000</span> / <span class="number">180</span> * pi,</span><br><span class="line">     <span class="number">1.440000</span> / <span class="number">180</span> * pi])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vcaculate</span>(<span class="params">omega,q</span>):</span><br><span class="line">    v=np.cross(-omega,q)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">v1=vcaculate(omega_1,q1)</span><br><span class="line">v2=vcaculate(omega_2,q2)</span><br><span class="line">v3=vcaculate(omega_3,q3)</span><br><span class="line">v4=vcaculate(omega_4,q4)</span><br><span class="line">v5=vcaculate(omega_5,q5)</span><br><span class="line">v6=vcaculate(omega_6,q6)</span><br><span class="line"></span><br><span class="line">s1=np.append(omega_1,v1)</span><br><span class="line">s2=np.append(omega_2,v2)</span><br><span class="line">s3=np.append(omega_3,v3)</span><br><span class="line">s4=np.append(omega_4,v4)</span><br><span class="line">s5=np.append(omega_5,v5)</span><br><span class="line">s6=np.append(omega_6,v6)</span><br><span class="line"></span><br><span class="line">Slist=np.array([s1,s2,s3,s4,s5,s6]).T</span><br><span class="line"><span class="comment"># print(M)</span></span><br><span class="line"><span class="comment"># print(v)</span></span><br><span class="line"><span class="comment"># print(thetalist)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = mr.FKinSpace(M,Slist,thetalist)</span><br><span class="line"><span class="built_in">print</span>(T)</span><br></pre></td></tr></table></figure>
<h3 id="一阶运动学和静力学">（5）一阶运动学和静力学</h3>
<p>机器人正运动学可以写成 <span class="math display">\[
x(t)=f(\theta(t))
\]</span> 对上式关于时间t求导 <span class="math display">\[
\dot{x}=\frac {\partial f(\theta) } {\partial \theta }\frac
{d(\theta(t)) } {dt }=\frac{\partial f(\theta)} {\partial \theta} =
J(\theta)\dot{\theta}
\]</span></p>
<p>式中，<span
class="math inline">\(J(\theta)\)</span>被称为雅可比，表示末端执行器速度相对关节速度的线性敏感度，时关于关节变量<span
class="math inline">\(\theta\)</span>的函数。在某些形位上，雅可比矩阵会变成奇异阵，相应的形位被称为奇异形位，特征主要表现在机器人在末端的某些方向上的速度不能实现。</p>
<p>雅可比矩阵可以用来将关节转速的边界映射到<span
class="math inline">\(v_{tip}\)</span>的边界中，如图5.2所示。不是如图那样将关节速度通过雅可比矩阵映射成多边形，而是在<span
class="math inline">\(\dot{\theta}_1-\dot{\theta}_2\)</span>平面内将关节速度映射成—个单位圆。这个圆表示关节速度空间的等廓线，其中驱动器的共同作用可考虑为关节速度的平方和。通过映射，单位圆映射成末端速度的—个椭球，这个椭球称为<strong>可操作度椭球</strong>。当操作手的位形接近奇异位形时，椭球将退化成一个线
段，末端沿某方向运动的能力将会丧失。</p>
<p>假设用于机器人运动的功忽略不计，机器人末端施加的功应与关节处产生的功相等，末端力向量记作<span
class="math inline">\(f_{tip}\)</span>关节力矩向量记作<span
class="math inline">\(\tau\)</span> 根据能量守恒定律可得</p>
<p>由于<span
class="math inline">\(v_{tip}=J(\theta)\dot{\theta}\)</span>，因此等式改写为</p>
<p>用于生成末端力<span
class="math inline">\(f_{tip}\)</span>的关节力矩<span
class="math inline">\(\tau\)</span>可以通过上式计算得到。如果机器人处于非奇异形位，雅可比矩阵及其转置矩阵可逆，可以写成</p>
<p>同样，类似于可操作度椭球，可以通过雅可比矩阵的逆转置，将<span
class="math inline">\(\tau_{1}-\tau_{2}\)</span>平面内的一个等廓单位圆映射成<span
class="math inline">\(f_{1}-f_{2}\)</span>末端力平面的一个椭球，这个椭球被称为<strong>力椭球</strong>。表示生成不同方向力的难易程度。</p>
<p>由可操作度椭球和力椭球明显可以看出，若在某—方向上比较容易地产生末端速度，该方向产生力就变得比较困难，反之亦然，具体如图5.6所示。事实上，对于给定的机器人位形，可操作度椭球与力椭球的主轴方问完全重合，但力椭球的主轴长度与可操作度椭球的主轴长度正好相反</p>
<h4 id="机器人雅可比">5.1机器人雅可比</h4>
<h5 id="空间雅可比">5.1.1空间雅可比</h5>
<p>考虑一个n杆的开链机器人，其正向运动学的指数积公式为</p>
<p>空间速度<span class="math inline">\(V_S\)</span>可以写成<span
class="math inline">\([V_S]=\dot{T}T^{-1}\)</span>，其中</p>
<p>可计算得</p>
<p>可通过伴随映射写成向量形式</p>
<p>矩阵<span
class="math inline">\(J_S(\theta)\)</span>即为空间固定坐标形式下得雅可比矩阵，简称为<strong>空间雅可比</strong>。</p>
<p><span class="math inline">\(J_{si}(\theta)\)</span>得第i列为</p>
<p>​ 第<span class="math inline">\(i\)</span>列的结构形式为<span
class="math inline">\(J_{si}(\theta)=Ad_{T_{i-1}}(S_{i})\)</span>其中<span
class="math inline">\(T_{i-1}=e^{[S_1\theta_1]}\cdots
e^{[S_{i-1}\theta_{i-1}]}\)</span>。回顾<span
class="math inline">\(S_i\)</span>为机器人处于零位时第i个关节相对固定坐标系的旋量坐标，因此<span
class="math inline">\(Ad_{T_{i-1}}(S_{i})\)</span>为该机器人经历刚体位移<span
class="math inline">\(T_{i-1}\)</span>之后的第i个关节相对固定坐标系的旋量坐标。物理上，这与前面的i-l个关节从零位到当前值theta1...theta_i-1时的旋量坐标是等效的。因此,<span
class="math inline">\(J_{s}(\theta)\)</span>的第i列<span
class="math inline">\(J_{si}(\theta)\)</span>只是描述第i个关节轴相对固定坐标系的旋量，同时也是关节变量theta1...theta_i-1的函数。不过是取任意的<span
class="math inline">\(\theta\)</span>值而不是<span
class="math inline">\(\theta\)</span>＝0。</p>
<h5 id="物体雅可比">5.1.2物体雅可比</h5>
<p>物体坐标系下，<span
class="math inline">\([V_b]=T^{-1}\dot{T}\)</span>，正运动学公式为</p>
<p>由此计算可得</p>
<p>以矩阵形式表示</p>
<p>矩阵<span
class="math inline">\(J_{b}(\theta)\)</span>即为物体坐标系下得雅可比行列式，简称<strong>物体雅可比</strong></p>
<h5 id="几何解释">5.1.3几何解释</h5>
<h5
id="空间雅可比和物体雅可比的关系">5.1.4空间雅可比和物体雅可比的关系</h5>
<h5
id="几何雅可比和解析雅可比的关系">5.1.5几何雅可比和解析雅可比的关系</h5>
<h4 id="开链机器人静力学">5.2开链机器人静力学</h4>
<h4 id="奇异性分析">5.3奇异性分析</h4>
<p>​
如在某个或者多个方向同时失去运动能力的位姿，我们称之为运动学奇异（kinematicsingularjty），或者简称为奇
异（singularity）。数学上,奇异位姿意味着雅可比矩阵<span
class="math inline">\(J(\theta)\)</span>不再满秩 。</p>
<p>​ 当<span
class="math inline">\(J(\theta)\)</span>的阶数降到最大值以下，奇异位姿对应此时的<span
class="math inline">\(\theta\)</span>。奇异位姿下末端坐标系丧失掉在某—维或多维方向的瞬时空间速度，这种奇异下损失的自由度同时伴随产生了与之对应方向上的约束力旋量
。</p>
<ul>
<li>2个旋转轴共轴</li>
<li>3各平面转动副轴线平行</li>
<li>4各转动副轴线共点</li>
<li>4个转动副轴线共面</li>
<li>6个转动副都与一条线相交</li>
</ul>
<h4 id="可操作度">5.4 可操作度</h4>
<p>对于一个通用的″关节开链机器人，任务空间的坐标为q，可操作度椭球对应的是当关节速率满足<span
class="math inline">\(|\dot{\theta}|=1\)</span>时末端执行器的速度。在n维关节速度空间内的一个单元球。假设<span
class="math inline">\(J\)</span>可逆,单位关节速度条件数可以写成</p>
<p>由线性代数可知，上式定义m维空间椭球。椭球主轴方向为<span
class="math inline">\(v_i\)</span>，主轴半径长为<span
class="math inline">\(\sqrt{\lambda_i}\)</span>。<strong>椭球的体积</strong>V与主轴半径长的乘积成正比。</p>
<p>角速度与线速度的量纲不同，于是将雅可比矩阵分开。由此可以得到两个三维可操作度椭球:一个表示角速度,另—个表示线速度。这两个可操作度椭球都有与A的特征向量相对应的主轴，长度为其特征值的平方根。其中，对于角速度可操作度椭球<span
class="math inline">\(J=J_\omega
J_\omega^T\)</span>，对于线速度可操作度椭球,<span
class="math inline">\(J=J_v J_v^T\)</span></p>
<p>当在计算线速度可操作度椭球时’使用<strong>物体雅可比<span
class="math inline">\(J_b\)</span></strong>更合适些,因为我们<strong>通常对末端坐标系原点的速度更感兴趣</strong>而非固定坐标系原点的速度。</p>
<p>除了可操作度椭球的几何特征之外,还有一种方法是定义可操作度椭球的<strong>最长轴半径与最短轴半径的比值</strong></p>
<p>当<span
class="math inline">\(\mu_1(A)\)</span>接近1时,可操作度椭球接近球形或者各向同性。意味着该机器人沿任何方向都同样容易，这是理想情况。相反,当机器人接近奇异时<span
class="math inline">\(\mu_1(A)\)</span>趋于无穷大 。</p>
<p>类似的，可以定义<span class="math inline">\(\mu_2(A)\)</span>为<span
class="math inline">\(\mu_1(A)\)</span>的平方，又称为矩阵A的<strong>条件数</strong>
，该值越小越理想。矩阵的条件数普遍用于衡量矩阵与向量相乘后的敏感度误差减少的程度
。</p>
<p>最后一种度量方法是简单利用<strong>可操作度椭球的体积</strong>，这种情况是越大越好。</p>
<p>与可操作度椭球类似，可以定义<strong>力椭球</strong>。
由单位关节力矩满足<span class="math inline">\(||{\tau}
||=1\)</span>，得到与上述类似的结果</p>
<p>因此，力椭球的主轴长度为可操作椭球长度的倒数。</p>
<h4 id="软件函数">5.5软件函数</h4>
<p>给定物体坐标系下描述的各关节旋量<span
class="math inline">\(B_i\)</span>及关节角，计算物体雅可比<span
class="math inline">\(J_B(\theta)\)</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jb=JacobianBody(Blist,thetalist)</span><br></pre></td></tr></table></figure>
<p>给定物体坐标系下描述的各关节旋量$ S_i<span
class="math inline">\(及关节角，计算物体雅可比\)</span>J_S()$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J=JacobianBody(Slist,thetalist)</span><br></pre></td></tr></table></figure>
<h3 id="逆运动学">（6）逆运动学</h3>
<h4 id="解析解">6.1解析解</h4>
<h5 id="几何法">6.1.1几何法</h5>
<h4 id="section"></h4>
<p>1.求解<span class="math inline">\(\theta_1 、\theta_2
、\theta_3\)</span> <span class="math display">\[
g_s(\theta)=e^{[S_1]\theta_1}\cdots e^{[S_{6}]\theta_{6}}M
\]</span> 右乘初始位姿<span
class="math inline">\(M\)</span>的逆矩阵，设<span
class="math inline">\(g_s(\theta)*M^{-1}=g\)</span>，得到 <span
class="math display">\[
g=e^{[S_1]\theta_1}\cdots e^{[S_{6}]\theta_{6}}
\]</span> 根据螺旋理论，位于螺旋轴上的<span
class="math inline">\(q\)</span>点，无论旋转多少角度，<span
class="math inline">\(q\)</span>点的位置保持不变，即 <span
class="math display">\[
e^{[S]\theta}*q=q
\]</span> 因此将上式右乘关节4、5、6的共同交点<span
class="math inline">\(q_6\)</span>，得 <span class="math display">\[
g*q_6=e^{[S_1]\theta_1}\cdots e^{[S_{3}]\theta_{3}}*q_6=(A,B,C,1)
\]</span></p>
<p>可知kuka
kr60后三轴相交于一点，符合pieper准则，具有封闭解。可知(A,B,C)为机器人相应姿态下的腕部中心坐标p，即4，5，6关节的共同交点。所以，前三轴决定机器人腕部中心的位置，后三轴决定机器人腕部中心的姿态。
<span class="math display">\[
q6 =[2020, 0, 960,1]
\]</span> 首先，使用几何法求解前三个关节。</p>
<p>通常情况下，库卡机器人前三轴具有四组逆运动学逆解，分别如图所示，左图对应的是左向位置（肘部向上和向下）,右图对应的是右向位置
（肘部向上和向下）</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051854731.png"
alt="image-20220305185457224" />
<figcaption aria-hidden="true">image-20220305185457224</figcaption>
</figure>
<p>对于关节1，运动学逆解有两个，如图所示。</p>
<p><img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051856658.jpg"
alt="img" /> <span class="math display">\[
\theta_{11} = atan2d(-py,px)；
\theta_{12} = atan2d(-py,px) + 180
\]</span> 对于关节2和3有两组解</p>
<p>情况一、</p>
<p><img src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051901311.jpg" alt="img" style="zoom:67%;" /></p>
<figure>
<img
src="file:///E:\qq记录\760088941\Image\C2C\E9B35D92825145DD7A275F895DBD70F0.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>情况二、</p>
<figure>
<img
src="file:///E:\qq记录\760088941\Image\C2C\970C64AC3887162C3074A0375214A803.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051903391.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由此，机器人前三关节的四组逆解就可以求出来了。</p>
<p>接下来使用POE正运动学公式，求出后三个关节的运动学逆解。</p>
<p>将机器人运动学模型式两边同右乘初始位姿，可得</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051906784.png"
alt="image-20220305190640702" />
<figcaption aria-hidden="true">image-20220305190640702</figcaption>
</figure>
<p>根据螺旋理论，位于转轴上的 q 点，无论旋转多少角度，q
点的位置保持不变，即</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051907522.png"
alt="image-20220305190718446" />
<figcaption aria-hidden="true">image-20220305190718446</figcaption>
</figure>
<p>因此将式（22）两边同时右乘关节 4、5、6 的共同 交点 q6，得</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051908182.png"
alt="image-20220305190804100" />
<figcaption aria-hidden="true">image-20220305190804100</figcaption>
</figure>
<p>点P的坐标(A,B,C)即机器人腕部中心在相应姿态下的坐标，求出前三轴坐标后，带入公式</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051911006.png"
alt="image-20220305191108924" />
<figcaption aria-hidden="true">image-20220305191108924</figcaption>
</figure>
<p>然后在转轴 ω6 上取一点 <span class="math inline">\(p_6 =
[0;0;960;1]\)</span>，并且该点不在 ω4、ω5 上， 于是得</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051911170.png"
alt="image-20220305191147083" />
<figcaption aria-hidden="true">image-20220305191147083</figcaption>
</figure>
<p>由POE正运动学公式可得</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051912112.png"
alt="image-20220305191258029" />
<figcaption aria-hidden="true">image-20220305191258029</figcaption>
</figure>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051913317.png"
alt="image-20220305191307219" />
<figcaption aria-hidden="true">image-20220305191307219</figcaption>
</figure>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051913130.png"
alt="image-20220305191319051" />
<figcaption aria-hidden="true">image-20220305191319051</figcaption>
</figure>
<p>T4*T5为</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051915325.png"
alt="image-20220305191531245" />
<figcaption aria-hidden="true">image-20220305191531245</figcaption>
</figure>
<p>T4XT5XP6为</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051920132.png"
alt="image-20220305192042032" />
<figcaption aria-hidden="true">image-20220305192042032</figcaption>
</figure>
<p>等式两边一一而对应，即可求出<span
class="math display">\[\theta_4,\theta_5\]</span></p>
<p>求得 θ4、θ5。又将 θ4、θ5代入正运动学公式并整理得</p>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051924463.png"
alt="image-20220305192405383" />
<figcaption aria-hidden="true">image-20220305192405383</figcaption>
</figure>
<figure>
<img
src="https://gitee.com/leiting2020/imagebed/raw/master/images/202203051924930.png"
alt="image-20220305192435842" />
<figcaption aria-hidden="true">image-20220305192435842</figcaption>
</figure>
<p><span
class="math inline">\(利用等式两边一一对应即可求出\theta_6\)</span></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line">X=[     <span class="number">0.995869</span>,    <span class="number">-0.025686</span>,    <span class="number">-0.087090</span>,  <span class="number">1480.441492</span> ;</span><br><span class="line">      <span class="number">0.024499</span>,     <span class="number">0.999592</span>,    <span class="number">-0.014667</span>,    <span class="number">60.437411</span> ;</span><br><span class="line">      <span class="number">0.087431</span>,     <span class="number">0.012473</span>,     <span class="number">0.996092</span>,  <span class="number">2212.432130</span> ;</span><br><span class="line">      <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">1.000000</span> ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% X=[    -0.000000,    -0.000000,     1.000000,  1340.000000 ;</span></span><br><span class="line"><span class="comment">%      -0.000000,     1.000000,     0.000000,    -0.000000 ;</span></span><br><span class="line"><span class="comment">%      -1.000000,    -0.000000,    -0.000000,  1810.000000 ;</span></span><br><span class="line"><span class="comment">%       0.000000,     0.000000,     0.000000,     1.000000 ];</span></span><br><span class="line"></span><br><span class="line">M=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2190</span>;</span><br><span class="line">   <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">  <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">960</span>;</span><br><span class="line">   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>   ]</span><br><span class="line"></span><br><span class="line"><span class="comment">%前三轴旋转轴</span></span><br><span class="line">s1=[<span class="number">0</span>;<span class="number">0</span>;<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]</span><br><span class="line">s2=[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-815</span>;<span class="number">0</span>;<span class="number">350</span>]</span><br><span class="line">s3=[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-815</span>;<span class="number">0</span>;<span class="number">1200</span>]</span><br><span class="line">s4=[<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">-960</span>;<span class="number">0</span>]</span><br><span class="line">s5=[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-960</span>;<span class="number">0</span>;<span class="number">2020</span>]</span><br><span class="line">s6=[<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">-960</span>;<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">%轴上任意一点</span></span><br><span class="line">q1 = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]&#x27;</span><br><span class="line">q2 = [<span class="number">350</span>, <span class="number">0</span>, <span class="number">815</span>]&#x27;</span><br><span class="line">q3 =[<span class="number">1200</span>, <span class="number">0</span>, <span class="number">815</span>]&#x27;</span><br><span class="line">q4 = [<span class="number">2020</span>, <span class="number">0</span>, <span class="number">960</span>]&#x27;</span><br><span class="line">q5 = [<span class="number">2020</span>, <span class="number">0</span>, <span class="number">960</span>]&#x27;</span><br><span class="line">q6 =[<span class="number">2020</span>, <span class="number">0</span>, <span class="number">960</span>]&#x27;</span><br><span class="line">q6_1 = [q6;<span class="number">1</span>]</span><br><span class="line">p = X  / M  *[q6;<span class="number">1</span>]</span><br><span class="line">px =p(<span class="number">1</span>)</span><br><span class="line">py =p(<span class="number">2</span>)</span><br><span class="line">pz =p(<span class="number">3</span>)</span><br><span class="line"><span class="comment">% px=1399.48736528</span></span><br><span class="line"><span class="comment">% py=58.90058846400001</span></span><br><span class="line"><span class="comment">% pz=942.73081665274</span></span><br><span class="line"><span class="comment">% px=1528.692;</span></span><br><span class="line"><span class="comment">% py=133.743;</span></span><br><span class="line"><span class="comment">% pz=931.186;</span></span><br><span class="line">o2a=<span class="number">850</span>;</span><br><span class="line">ab=<span class="number">145</span>;</span><br><span class="line">bp=<span class="number">820</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">theta1_1 = atan2d(-py,px)</span><br><span class="line">theta1_2 = atan2d(-py,px) + <span class="number">180</span></span><br><span class="line"></span><br><span class="line">ap=<span class="built_in">sqrt</span>(<span class="number">145</span>^<span class="number">2</span>+<span class="number">820</span>^<span class="number">2</span>);</span><br><span class="line">o2w=<span class="built_in">sqrt</span>(px^<span class="number">2</span>+py^<span class="number">2</span>)<span class="number">-350</span>;</span><br><span class="line">pw=pz<span class="number">-815</span>;</span><br><span class="line">o2p=<span class="built_in">sqrt</span>(o2w^<span class="number">2</span>+pw^<span class="number">2</span>);</span><br><span class="line">angle_ao2p=<span class="built_in">acosd</span>((o2a^<span class="number">2</span>+o2p^<span class="number">2</span>-ap^<span class="number">2</span>)/(<span class="number">2</span>*o2a*o2p));</span><br><span class="line">angle_po2w=<span class="built_in">acosd</span>((o2p^<span class="number">2</span>+o2w^<span class="number">2</span>-pw^<span class="number">2</span>)/(<span class="number">2</span>*o2p*o2w));</span><br><span class="line">theta2_1=-(angle_ao2p+angle_po2w)</span><br><span class="line"></span><br><span class="line">angle_PO2W = <span class="built_in">acosd</span>((o2p^<span class="number">2</span>+o2w^<span class="number">2</span>-pw^<span class="number">2</span>)/(<span class="number">2</span>*o2p*o2w));</span><br><span class="line">angle_PO2A = <span class="built_in">acosd</span>((o2p^<span class="number">2</span>+o2a^<span class="number">2</span>-ap^<span class="number">2</span>)/(<span class="number">2</span>*o2p*o2a));</span><br><span class="line">theta2_2 = angle_PO2A - angle_PO2W</span><br><span class="line"></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">angle_bap = atan2d(bp,ab);</span><br><span class="line">angle_o2ap=<span class="built_in">acosd</span>((o2a^<span class="number">2</span>+ap^<span class="number">2</span>-o2p^<span class="number">2</span>)/(<span class="number">2</span>*o2a*ap));</span><br><span class="line">theta3_1 = <span class="number">270</span>- angle_bap-angle_o2ap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o2c = o2w/<span class="built_in">cosd</span>(-theta2_2);</span><br><span class="line">wc = o2w*<span class="built_in">tand</span>(-theta2_2);</span><br><span class="line">ac=o2c-o2a;</span><br><span class="line">pc = pw-wc;</span><br><span class="line">pw;</span><br><span class="line">ap;</span><br><span class="line"></span><br><span class="line">angle_PAC = <span class="built_in">acosd</span>((ap^<span class="number">2</span>+ac^<span class="number">2</span>-pc^<span class="number">2</span>)/(<span class="number">2</span>*ap*ac));</span><br><span class="line">angle_BAP = atan2d(bp,ab);</span><br><span class="line">theta3_2 = <span class="number">90</span>-(angle_PAC + angle_BAP)</span><br><span class="line"></span><br><span class="line"><span class="comment">%后三轴计算</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% theta4=-0.78</span></span><br><span class="line"><span class="comment">% theta5=-54.89</span></span><br><span class="line"><span class="comment">% theta6=1.44</span></span><br><span class="line"></span><br><span class="line">T1=trans(s1,theta1_1)</span><br><span class="line">T2=trans(s2,theta2_1)</span><br><span class="line">T3=trans(s3,theta3_1)</span><br><span class="line"><span class="comment">% T4=trans(s4,theta4)</span></span><br><span class="line"><span class="comment">% T5=trans(s5,theta5)</span></span><br><span class="line"><span class="comment">% T6=trans(s6,theta6)</span></span><br><span class="line"></span><br><span class="line">T_0 = inv(T3)*inv(T2)*inv(T1)*X*inv(M)*[<span class="number">0</span>;<span class="number">0</span>;<span class="number">960</span>;<span class="number">1</span>]</span><br><span class="line">costheta5 = <span class="number">1</span>-T_0(<span class="number">1</span>)/<span class="number">2020</span></span><br><span class="line">theta5=atan2d(-<span class="built_in">sqrt</span>(<span class="number">1</span>-costheta5^<span class="number">2</span>),costheta5)</span><br><span class="line">T5=trans(s5,theta5)</span><br><span class="line"></span><br><span class="line">costheta4 = (T_0(<span class="number">3</span>) - <span class="number">960</span>)/(<span class="number">2020</span>*<span class="built_in">sind</span>(theta5))</span><br><span class="line">theta4=atan2d(-<span class="built_in">sqrt</span>(<span class="number">1</span>-costheta4^<span class="number">2</span>),costheta4)</span><br><span class="line">T4=trans(s4,theta4)</span><br><span class="line"></span><br><span class="line">T_1 = inv(T5)*inv(T4)*inv(T3)*inv(T2)*inv(T1)*X*inv(M)</span><br><span class="line">theta6=<span class="built_in">acosd</span>(T_1(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">T</span>=<span class="title">trans</span><span class="params">(s,theta)</span></span></span><br><span class="line">    se3mat = VecTose3(s);</span><br><span class="line">    theta = theta /180 * <span class="built_in">pi</span>;</span><br><span class="line">    se3mat = se3mat * theta;</span><br><span class="line">    T = MatrixExp6(se3mat);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="pk子问题解法">6.1.2 pk子问题解法</h5>
<p>求解分为两部，第一部分求解前三轴关节角，第二部分求解后三轴关节角。</p>
<p>为了便于求解后三轴关节角，将机器人初始位姿定位[0,0,0,0,90,0],即第五轴旋转90度，使后三轴交于一点的同时互相正交。同时求解出来的关节角结果的第五轴需要加上90度。</p>
<p>第五轴90度旋转后的初始形位为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M=[    -1.000000,    -0.000000,     0.000000,  2020.000000 ;</span><br><span class="line">     -0.000000,     1.000000,     0.000000,     0.000000 ;</span><br><span class="line">     -0.000000,     0.000000,    -1.000000,   790.000000 ;</span><br><span class="line">      0.000000,     0.000000,     0.000000,     1.000000 ];</span><br></pre></td></tr></table></figure>
<h6 id="前三轴">前三轴</h6>
<p>因为前三轴并不相交，所以只能把前三轴分解为三个子问题1进行求解。</p>
<p><strong>图中坐标系情况与实际情况不同</strong></p>
<p>​
p1为腕部中心坐标，正运动学公式两边同时乘以初始形位下机器人腕部中心坐标r4=[2020;0;960]，可以求解出来目标形位下腕部中心坐标为p1=（px,py,pz）</p>
<p>​
从图中可以看出o1（不一定是o点）与p1共面，同时，o1位于关节轴1上，所以o1的坐标为o1=[0;0;pz]；</p>
<p>​ p2也与p1共面，也与o2共面，由|p1o1| = |p2o2|，即可求解出<span
class="math inline">\(p_2=[(-)\sqrt{(px^2+py^2)},0,pz]\)</span>,p2有两种情况。</p>
<p>​ <span
class="math inline">\(o_2=[350;0;815],o_3=[1200;0;815]\)</span>，<span
class="math inline">\(由|r_4o_3|=|p_3o_3|,|p_2o_2|=|p_3o_2|\)</span>，可以求出p3点的坐标。</p>
<p>​ 将前三关节角分解为三个子问题1，前三个关节螺旋运动表示为</p>
<p>​ <strong>pk子问题1</strong>如图所示</p>
<p>等价于</p>
<p>关节角<span class="math inline">\(\theta\)</span>可以由公式求出</p>
<p>由此，前三个关节角即可求出。</p>
<blockquote>
<p>注意：有些形位p3点的坐标求出来是虚数，即第二轴求解可能会有无解的情况，虽然理论上机器人前三轴有4组解，但是有些位置关节角可能无法达到，可能不足4组解。在程序中，遇到p3坐标为虚数的情况就跳出此次循环，进入下一循环。</p>
</blockquote>
<h6 id="后三轴">后三轴</h6>
<p>在公式中将求解的前三个关节角右移</p>
<p>乘以一个在轴6上但不在45轴上的点p=[2020;0;0;1]。可以消去第六轴的旋转。</p>
<p>因为4，5轴交于一点r4，即可使用PK子问题2对关节45进行求解。</p>
<p><strong>pk子问题2</strong></p>
<p>令z为</p>
<p>则</p>
<p><span class="math inline">\(\alpha 和\beta
即可通过公式求出\)</span></p>
<p>同时<span class="math inline">\(\gamma
有两组解\)</span>，对应于后三轴有两组解的情况</p>
<p>求出z后，子问题2就转换为两个子问题1，可以使用子问题一进行求解。</p>
<p>求解出关节45后，带入公式，两端乘以不在轴6上的一点p7=[2021;0;0]</p>
<p>同样使用子问题1进行求解出关节6</p>
<p>求解完所有的关节后，将<strong>关节五加上90度</strong>，即为实际情况的关节角。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"><span class="comment">%目标形位</span></span><br><span class="line">X=[     <span class="number">0.829242</span>,    <span class="number">-0.423859</span>,     <span class="number">0.364283</span>,   <span class="number">546.623076</span> ;</span><br><span class="line">      <span class="number">0.407748</span>,     <span class="number">0.904588</span>,     <span class="number">0.124342</span>,   <span class="number">282.228651</span> ;</span><br><span class="line">     <span class="number">-0.382230</span>,     <span class="number">0.045426</span>,     <span class="number">0.922950</span>,  <span class="number">1798.527619</span> ;</span><br><span class="line">      <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">1.000000</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% X=[    -0.000000,    -0.000000,     1.000000,  1340.000000 ;</span></span><br><span class="line"><span class="comment">%      -0.000000,     1.000000,     0.000000,    -0.000000 ;</span></span><br><span class="line"><span class="comment">%      -1.000000,    -0.000000,    -0.000000,  1810.000000 ;</span></span><br><span class="line"><span class="comment">%       0.000000,     0.000000,     0.000000,     1.000000 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% M=[0, 0, 1, 2190;</span></span><br><span class="line"><span class="comment">%    0, 1, 0, 0;</span></span><br><span class="line"><span class="comment">%   -1, 0, 0, 960;</span></span><br><span class="line"><span class="comment">%    0, 0, 0, 1   ]</span></span><br><span class="line"><span class="comment">%初始形位，不是所有的关节为零，第五关节旋转90°，在最后计算角度时，第五轴应减去90°</span></span><br><span class="line">M=[    <span class="number">-1.000000</span>,    <span class="number">-0.000000</span>,     <span class="number">0.000000</span>,  <span class="number">2020.000000</span> ;</span><br><span class="line">     <span class="number">-0.000000</span>,     <span class="number">1.000000</span>,     <span class="number">0.000000</span>,     <span class="number">0.000000</span> ;</span><br><span class="line">     <span class="number">-0.000000</span>,     <span class="number">0.000000</span>,    <span class="number">-1.000000</span>,   <span class="number">790.000000</span> ;</span><br><span class="line">      <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">0.000000</span>,     <span class="number">1.000000</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">%前三轴旋转轴</span></span><br><span class="line">s(<span class="number">1</span>)=&#123;[<span class="number">0</span>;<span class="number">0</span>;<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]&#125;</span><br><span class="line">s(<span class="number">2</span>)=&#123;[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-815</span>;<span class="number">0</span>;<span class="number">350</span>]&#125;</span><br><span class="line">s(<span class="number">3</span>)=&#123;[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-815</span>;<span class="number">0</span>;<span class="number">1200</span>]&#125;</span><br><span class="line">s(<span class="number">4</span>)=&#123;[<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">-960</span>;<span class="number">0</span>]&#125;</span><br><span class="line">s(<span class="number">5</span>)=&#123;[<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>;<span class="number">-960</span>;<span class="number">0</span>;<span class="number">2020</span>]&#125;</span><br><span class="line"></span><br><span class="line">w1 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">-1</span>]</span><br><span class="line">w2 = [<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>]</span><br><span class="line">w3 = [<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>]</span><br><span class="line">w4 = [<span class="number">-1</span>;<span class="number">0</span>;<span class="number">0</span>]</span><br><span class="line">w5 = [<span class="number">0</span>;<span class="number">1</span>;<span class="number">0</span>]</span><br><span class="line"><span class="comment">%旋转90后</span></span><br><span class="line">w6 = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]</span><br><span class="line"><span class="comment">%轴上任意一点</span></span><br><span class="line">q(<span class="number">1</span>) = &#123;[<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>]&#125;</span><br><span class="line">q(<span class="number">2</span>) = &#123;[<span class="number">350</span>;<span class="number">0</span>;<span class="number">815</span>]&#125;</span><br><span class="line">q(<span class="number">3</span>) =&#123;[<span class="number">1200</span>;<span class="number">0</span>;<span class="number">815</span>]&#125;</span><br><span class="line">q(<span class="number">4</span>) = &#123;[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">960</span>]&#125;</span><br><span class="line">q(<span class="number">5</span>) = &#123;[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">960</span>]&#125;</span><br><span class="line">q(<span class="number">6</span>) =&#123;[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">960</span>]&#125;</span><br><span class="line"><span class="comment">%腕部中心</span></span><br><span class="line">q6_1 = [q&#123;<span class="number">6</span>&#125;;<span class="number">1</span>]</span><br><span class="line">p0 = X  / M  *q6_1</span><br><span class="line">px =p0(<span class="number">1</span>)</span><br><span class="line">py =p0(<span class="number">2</span>)</span><br><span class="line">pz =p0(<span class="number">3</span>)</span><br><span class="line"><span class="comment">%前三轴计算</span></span><br><span class="line">o1=[<span class="number">0</span>;<span class="number">0</span>;pz]</span><br><span class="line">o2=[<span class="number">350</span>;<span class="number">0</span>;<span class="number">815</span>]</span><br><span class="line">o3=[<span class="number">1200</span>;<span class="number">0</span>;<span class="number">815</span>]</span><br><span class="line">r4 = [<span class="number">2020</span>;<span class="number">0</span>;<span class="number">960</span>]</span><br><span class="line">p1=[px;py;pz]</span><br><span class="line">p1o1=o1 - p1</span><br><span class="line">r4o3=o3-r4</span><br><span class="line">anglenum=<span class="number">0</span>  <span class="comment">%关节角组数</span></span><br><span class="line"><span class="keyword">for</span> p2num = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="comment">%前三轴可分解为三个pk子问题1进行计算</span></span><br><span class="line">    <span class="comment">%两种p2情况</span></span><br><span class="line">    p2(p2num) = &#123;[(<span class="number">-1</span>)^(p2num+<span class="number">1</span>)*<span class="built_in">sqrt</span>(px^<span class="number">2</span>+py^<span class="number">2</span>);<span class="number">0</span>;pz]&#125;</span><br><span class="line">    p2o1(p2num)=&#123;o1 - p2&#123;p2num&#125;&#125;</span><br><span class="line">    p2o2(p2num)=&#123;o2 - p2&#123;p2num&#125;&#125;</span><br><span class="line">     <span class="comment">%关节1</span></span><br><span class="line">    theta1(p2num) = atan2d(w1&#x27; * (<span class="built_in">cross</span>(p2o1&#123;p2num&#125;,p1o1)), p2o1&#123;p2num&#125;&#x27;*p1o1)</span><br><span class="line">    x(p2num)=( norm(r4o3)^<span class="number">2</span>-norm(p2o2&#123;p2num&#125;)^<span class="number">2</span><span class="number">-1200</span>^<span class="number">2</span>+<span class="number">350</span>^<span class="number">2</span> ) /(<span class="number">-1700</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%每个p2对应两个p3</span></span><br><span class="line">    <span class="keyword">for</span> p3num = (<span class="number">2</span>*p2num<span class="number">-1</span>):(<span class="number">2</span>*p2num)</span><br><span class="line">        <span class="comment">%若求解出来的是虚数，说明这组关节角无解，跳出此次循环，进行下一组关节角计算</span></span><br><span class="line">        <span class="keyword">if</span> ~<span class="built_in">isreal</span>(<span class="built_in">sqrt</span>( <span class="number">820</span>^<span class="number">2</span>+<span class="number">145</span>^<span class="number">2</span>-(x(p2num)<span class="number">-1200</span>)^<span class="number">2</span> ))</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        z(p3num) = <span class="number">815</span> + (<span class="number">-1</span>)^(p3num+<span class="number">1</span>)*<span class="built_in">sqrt</span>( <span class="number">820</span>^<span class="number">2</span>+<span class="number">145</span>^<span class="number">2</span>-(x(p2num)<span class="number">-1200</span>)^<span class="number">2</span> )</span><br><span class="line">        <span class="comment">%求出p3点</span></span><br><span class="line">        p3(p3num)=&#123;[x(p2num);<span class="number">0</span>;z(p3num)]&#125;</span><br><span class="line">        p3o2(p3num) =&#123;o2 - p3&#123;p3num&#125;&#125;</span><br><span class="line">        p3o3(p3num) = &#123;o3 - p3&#123;p3num&#125;&#125;</span><br><span class="line">        <span class="comment">%关节2</span></span><br><span class="line">        theta2(p3num) = atan2d(w2&#x27; * (<span class="built_in">cross</span>(p3o2&#123;p3num&#125;,p2o2&#123;p2num&#125;)), <span class="built_in">dot</span>(p3o2&#123;p3num&#125;,p2o2&#123;p2num&#125;)) </span><br><span class="line">        <span class="comment">%关节3</span></span><br><span class="line">        theta3(p3num) = atan2d(w3&#x27; * (<span class="built_in">cross</span>(r4o3,p3o3&#123;p3num&#125;)), <span class="built_in">dot</span>(r4o3,p3o3&#123;p3num&#125;))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%求后三轴</span></span><br><span class="line">        T1=trans(s&#123;<span class="number">1</span>&#125;,theta1(p2num))</span><br><span class="line">        T2=trans(s&#123;<span class="number">2</span>&#125;,theta2(p3num))</span><br><span class="line">        T3=trans(s&#123;<span class="number">3</span>&#125;,theta3(p3num))</span><br><span class="line">        <span class="comment">%将后三轴分解为一个pk子问题2和一个pk子问题1</span></span><br><span class="line">        <span class="comment">%首先求解一个子问题2</span></span><br><span class="line">        <span class="comment">%乘以在6轴上但是不在45轴上的一点</span></span><br><span class="line">        T_0 = inv(T3)*inv(T2)*inv(T1)*X*inv(M)*[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]</span><br><span class="line">        q = T_0(<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">        p=[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">0</span>]</span><br><span class="line">        r=[<span class="number">2020</span>;<span class="number">0</span>;<span class="number">960</span>]</span><br><span class="line">        u=p-r</span><br><span class="line">        v=q-r</span><br><span class="line">        u50 = u - w5*w5&#x27;*u</span><br><span class="line">        v40=v-w4*w4&#x27;*v</span><br><span class="line">        alpha = ((w4&#x27;*w5)*w5&#x27;*u - w4&#x27;*v)/( (w4&#x27;*w5)^<span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">beta</span> = ((w4&#x27;*w5)*w4&#x27;*v - w5&#x27;*u)/( (w4&#x27;*w5)^<span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> znum = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">            <span class="comment">%gama有两个解，所以z点也有两个解</span></span><br><span class="line">            gama(znum)=(<span class="number">-1</span>)^(znum+<span class="number">1</span>)*<span class="built_in">sqrt</span>(( (norm(u))^<span class="number">2</span> - alpha^<span class="number">2</span> - <span class="built_in">beta</span>^<span class="number">2</span> <span class="number">-2</span>*alpha*<span class="built_in">beta</span>*w4&#x27;*w5 )/( norm(<span class="built_in">cross</span>(w4,w5)) )^<span class="number">2</span>)</span><br><span class="line">            z1(znum)= &#123;alpha * w4 + <span class="built_in">beta</span> * w5 + gama(znum) * (<span class="built_in">cross</span>(w4,w5))&#125;</span><br><span class="line">            z0(znum) = &#123;z1&#123;znum&#125; - w5*w5&#x27;*z1&#123;znum&#125;&#125;</span><br><span class="line">            <span class="comment">%第五轴</span></span><br><span class="line">            theta5(znum) = atan2d(w5&#x27; * (<span class="built_in">cross</span>(u50,z0&#123;znum&#125; )), <span class="built_in">dot</span>(u50,z0&#123;znum&#125;))</span><br><span class="line">            <span class="comment">%计算第六轴</span></span><br><span class="line">            z2(znum) = &#123;z1&#123;znum&#125; - w4*w4&#x27;*z1&#123;znum&#125;&#125;</span><br><span class="line">            theta4(znum) = atan2d(w4&#x27; * (<span class="built_in">cross</span>(z2&#123;znum&#125;,v40 )), <span class="built_in">dot</span>(z2&#123;znum&#125;,v40))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">%乘以不在6轴上的一点，利用子问题1求解关节6</span></span><br><span class="line">            T4=trans(s&#123;<span class="number">4</span>&#125;,theta4(znum))</span><br><span class="line">            T5=trans(s&#123;<span class="number">5</span>&#125;,theta5(znum))</span><br><span class="line">            T_1 = inv(T5)*inv(T4)*inv(T3)*inv(T2)*inv(T1)*X*inv(M)*[<span class="number">2021</span>;<span class="number">0</span>;<span class="number">0</span>;<span class="number">1</span>]</span><br><span class="line">            q7 = T_1(<span class="number">1</span>:<span class="number">3</span>)</span><br><span class="line">            p7=[<span class="number">2021</span>;<span class="number">0</span>;<span class="number">0</span>]</span><br><span class="line">            u6=r-p7</span><br><span class="line">            v6=r-q7</span><br><span class="line">            u60 = u6 - w6*w6&#x27;*u6</span><br><span class="line">            v60 = v6 - w6*w6&#x27;*v6</span><br><span class="line">            theta6(znum) = atan2d(w6&#x27; * (<span class="built_in">cross</span>(u60,v60)), <span class="built_in">dot</span>(u60,v60))</span><br><span class="line">            anglenum= anglenum+<span class="number">1</span>;</span><br><span class="line">            thetalist(anglenum)=&#123;[theta1(p2num),theta2(p3num),theta3(p3num),theta4(znum),theta5(znum),theta6(znum)]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:anglenum  </span><br><span class="line">    theta(<span class="built_in">i</span>,:)=thetalist&#123;<span class="built_in">i</span>&#125;;   </span><br><span class="line">    theta(<span class="built_in">i</span>,<span class="number">5</span>)=theta(<span class="built_in">i</span>,<span class="number">5</span>)+<span class="number">90</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">theta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">T</span>=<span class="title">trans</span><span class="params">(s,theta)</span></span></span><br><span class="line">    se3mat = VecTose3(s);</span><br><span class="line">    theta = theta /180 * <span class="built_in">pi</span>;</span><br><span class="line">    se3mat = se3mat * theta;</span><br><span class="line">    T = MatrixExp6(se3mat);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="数值解">6.2数值解</h4>
<h5 id="牛顿-拉夫森法">1.牛顿-拉夫森法</h5>
<p>利用泰勒级数在<span
class="math inline">\(\theta^0\)</span>处展开，截取第一项</p>
<p>保留第一阶，令<span class="math inline">\(g(\theta)=0\)</span>，得到$
$，作为初值带入方程，重复求解得到</p>
<p>通过不断迭代，直到满足阈值</p>
<h5 id="逆运动学数值算法">2.逆运动学数值算法</h5>
<p>令<span
class="math inline">\(x_d\)</span>为预期得末端坐标，牛顿-拉夫森法中得<span
class="math inline">\(g(\theta)\)</span>可以定义为<span
class="math inline">\(g(\theta)=x_d-f(\theta)\)</span>，目标是找到关节坐标<span
class="math inline">\(x_d\)</span>，且保证 <span class="math display">\[
g(\theta_d)=x_d-f(\theta_d)=0
\]</span></p>
<p>截取泰勒级数到第一项</p>
<p>若正向运动学是关节角的线性函数，即式的高阶项为0，这时新的估计值<span
class="math inline">\(\theta^1=\theta^0+\Delta\theta\)</span>精确满足<span
class="math inline">\(x_d=0\)</span>。相反，若正向运动学是关节角的非线性函数,就如通常情况,这时新的估计值<span
class="math inline">\(\theta^1\)</span>比<span
class="math inline">\(\theta^0\)</span>更接近真实值，迭代过程不断重复，并产生一系列的关节角值{<span
class="math inline">\(\theta^0 \theta^1 \theta^2
\dots\)</span>}最终在<span
class="math inline">\(\theta_d\)</span>处收敛。</p>
<p>如果逆运动学存在多组解，迭代过程趋向于收敛到与初始值最接近的解，你可以想象到每组解都有其存在的区域，若初始估计值不在这些区域中（如初始值与真实值没有足够接近）,迭代过程可能不收敛
。</p>
<p>实际上，由于计算效率等原因，公式经常不采用求逆<span
class="math inline">\(J^{-1}(\theta^0)\)</span>的方式来求解，可以找到更高效的方法求解线性方程Ax＝b中的x。例如，对于可逆阵A，基于A的LU分解可以用更少的运算得到x。</p>
<p>分为两大类</p>
<ul>
<li><p>方程解<span class="math inline">\(y^*\)</span>精确满足<span
class="math inline">\(Jy^*=z\)</span></p></li>
<li><p>设定<span
class="math inline">\(\theta^{i+1}=\theta^i+J^+(\theta^i)e\)</span></p></li>
<li><p>增加<span class="math inline">\(i\)</span></p></li>
</ul>
<p>为修改上述算法，使之能应用在预期末端位形为SE（3）而不是坐标向量xd的情况。可将关节坐标雅可比替换成末端物体雅可比。</p>
<p>首先需计算相对物体坐标系得预期变形 <span class="math display">\[
T_{bd}(\theta^i)=T_{sb}^{-1}(\theta^i)T_{sd}=T_{bs}(\theta^i)T_{sd}
\]</span> 然后利用矩阵对数<span class="math inline">\(V_b\)</span>，即
<span class="math display">\[
[V_b]=logT_{bd}(\theta^i)
\]</span> 由此给出逆运动学算法</p>
<p>(a)初始化：已知<span
class="math inline">\(T_{sd}\)</span>，初始化估计值$ ^0$，设定i=0;</p>
<p>(b)设定<span
class="math inline">\([V_b]=log(T_{sb}^{-1}(\theta^i)T_{sd})\)</span>，当<span
class="math inline">\(||\omega_b||&gt;\varepsilon_{\omega}\)</span>或者<span
class="math inline">\(|v_b||&gt;\varepsilon_{v}\)</span></p>
<ul>
<li>设定<span
class="math inline">\(\theta^{i+1}=\theta^i+J^+(\theta^i)V_b\)</span></li>
<li>增加<span class="math inline">\(i\)</span></li>
</ul>
<p>基于空间坐标系也可导出另一种形式利用空间雅可比和空间速度旋量<span
class="math inline">\(V_s=[Ad_{T_{sb}}]V_b\)</span></p>
<h4 id="逆向速度运动学">6.3逆向速度运动学</h4>
<h4 id="软件">6.4软件</h4>
<p>该函数主要是已知末端坐标系中描述的关节旋量B，末端初始位形M、预期的末端位形T，关节角的初始估计值$
^0 <span class="math inline">\(、以及最小误差\)</span> _<span
class="math inline">\(和\)</span>
_v$，利用迭代牛顿-拉夫森算法来计算逆运动学，若在经过—定次数的迭代之后还无法收敛，算法失效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">［theta11st,success］＝IKinBody（B1ist,M,T,theta1ist,eomg,ev）</span><br></pre></td></tr></table></figure>
<p>该函数功能类似于lKinBody，只是关节旋量在空间坐标系下来描述，所有的误差也在空间坐标系内来表达。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">［theta11st,success］＝IKinSpace（B1ist,M,T,theta1ist,eomg,ev）</span><br></pre></td></tr></table></figure>
<h2 id="改进d-h建模">2.改进D-H建模</h2>
<h3 id="d-h参数">（1）D-H参数</h3>
<p>机器人工具箱中中定义改进DH连杆时一定要注意DH[theta d a
alpha]中<strong>前两个参数下表为i</strong>，即当前关节的DH值，后<strong>两个参数</strong>下表为i-1，及前一个关节的DH值参数值！</p>
<p>此时对比代码中的DH参数和图中画的坐标系，得到DH定义为</p>
<blockquote>
<p>theta(i)：绕Zi轴，从Xi-1旋转到Xi的角度</p>
<p>d(i)：沿Zi轴，从Xi-1移动到Xi的距离</p>
<p>a(i)：沿Xi轴，从Zi移动到Zi+1的距离</p>
<p>alpha(i)：绕Xi轴，从Zi旋转到Zi+1的角度</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>杆件</th>
<th>theta</th>
<th>d</th>
<th>a</th>
<th>alpha</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td>815</td>
<td>350</td>
<td>-90</td>
</tr>
<tr class="odd">
<td>2</td>
<td>-90</td>
<td>0</td>
<td>850</td>
<td>0</td>
</tr>
<tr class="even">
<td>3</td>
<td>0</td>
<td>0</td>
<td>145</td>
<td>-90</td>
</tr>
<tr class="odd">
<td>4</td>
<td>0</td>
<td>820</td>
<td>0</td>
<td>90</td>
</tr>
<tr class="even">
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-90</td>
</tr>
<tr class="odd">
<td>6</td>
<td>180</td>
<td>180</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>所以在程序中定义DH参数：</p>
<table>
<thead>
<tr class="header">
<th>杆件</th>
<th>theta</th>
<th>d</th>
<th>a</th>
<th>alpha</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>815</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>2</td>
<td>-90</td>
<td>0</td>
<td>350</td>
<td>-90</td>
</tr>
<tr class="odd">
<td>3</td>
<td>0</td>
<td>0</td>
<td>850</td>
<td>0</td>
</tr>
<tr class="even">
<td>4</td>
<td>0</td>
<td>820</td>
<td>145</td>
<td>-90</td>
</tr>
<tr class="odd">
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>90</td>
</tr>
<tr class="even">
<td>6</td>
<td>180</td>
<td>180</td>
<td>0</td>
<td>-90</td>
</tr>
</tbody>
</table>
<p>上图所示为机器人处于位姿原点位置，在D-H模型中关节转角theta为[0,-90,0,0,0,180]，而实际的机器人处于原点位姿的关节转角theta'为[0,-90,90,0,0,0]，这是由于机器人关节零位和旋转方向定义与D-H模型不同造成的，实际机器人与D-H模型第一，四，六轴的旋转方向相反，第三、六轴分别差-90°和180°，需要对理论模型和实际模型的关节转角转换关系进行明确的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">theta1=-theta1&#x27;;</span><br><span class="line"></span><br><span class="line">theta2=-theta2&#x27;;</span><br><span class="line"></span><br><span class="line">theta3=theta3&#x27;-90;</span><br><span class="line"></span><br><span class="line">theta4=-theta4&#x27;;</span><br><span class="line"></span><br><span class="line">theta5=-theta5&#x27;</span><br><span class="line"></span><br><span class="line">theta6=180-theta6&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="建模程序">（2）建模程序</h3>
<p>使用python中的机器人工具箱进行D-H建模,程序命名为KR60.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> roboticstoolbox <span class="keyword">as</span> rtb</span><br><span class="line"><span class="keyword">from</span> spatialmath <span class="keyword">import</span> SE3</span><br><span class="line"><span class="keyword">from</span> roboticstoolbox <span class="keyword">import</span> DHRobot, RevoluteDH, RevoluteMDH</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KR60</span>(<span class="title class_ inherited__">DHRobot</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        deg = pi / <span class="number">180</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Updated values form ARTE git. Old values left as comments</span></span><br><span class="line"></span><br><span class="line">        L1 = RevoluteMDH(a=<span class="number">0</span>,</span><br><span class="line">                         d=<span class="number">0.815</span>,</span><br><span class="line">                         alpha=<span class="number">0</span>,  <span class="comment"># alpha=pi / 2,</span></span><br><span class="line">                         <span class="comment"># theta=0,</span></span><br><span class="line">                         qlim=[-<span class="number">185</span> * deg, <span class="number">185</span> * deg]</span><br><span class="line">                        )</span><br><span class="line">        L2 = RevoluteMDH(a=<span class="number">0.35</span>,</span><br><span class="line">                         d=<span class="number">0</span>,  <span class="comment"># d=0.135,</span></span><br><span class="line">                         alpha=-pi/<span class="number">2</span>,  <span class="comment"># alpha=pi,</span></span><br><span class="line">                         <span class="comment"># theta=0,</span></span><br><span class="line">                         qlim=[-<span class="number">135</span> * deg, <span class="number">35</span> * deg]</span><br><span class="line">                        )</span><br><span class="line">        L3 = RevoluteMDH(a=<span class="number">0.85</span>,</span><br><span class="line">                        d=<span class="number">0</span>,  <span class="comment"># d=0.135,</span></span><br><span class="line">                        alpha=<span class="number">0</span>,  <span class="comment"># alpha=-pi / 2,</span></span><br><span class="line">                        <span class="comment"># theta=-pi/2,</span></span><br><span class="line">                        qlim=[-<span class="number">120</span> * deg, <span class="number">158</span> * deg]</span><br><span class="line">                        )</span><br><span class="line">        L4 = RevoluteMDH(a=<span class="number">0.145</span>,</span><br><span class="line">                        d=<span class="number">0.82</span>,  <span class="comment"># d=0.62,</span></span><br><span class="line">                        alpha=-pi/<span class="number">2</span>,  <span class="comment"># alpha=pi / 2,</span></span><br><span class="line">                        <span class="comment"># theta=0,</span></span><br><span class="line">                        qlim=[-<span class="number">350</span> * deg, <span class="number">350</span> * deg]</span><br><span class="line">                        )</span><br><span class="line">        L5 = RevoluteMDH(a=<span class="number">0.0</span>,</span><br><span class="line">                        d=<span class="number">0.0</span>,</span><br><span class="line">                        alpha=pi/<span class="number">2</span>,  <span class="comment"># alpha=-pi / 2,</span></span><br><span class="line">                        <span class="comment"># theta=0,</span></span><br><span class="line">                        qlim=[-<span class="number">119</span> * deg, <span class="number">119</span> * deg]</span><br><span class="line">                        )</span><br><span class="line">        L6 = RevoluteMDH(a=<span class="number">0</span>,</span><br><span class="line">                        d=<span class="number">0.17</span>,</span><br><span class="line">                        alpha=-pi/<span class="number">2</span>,</span><br><span class="line">                        <span class="comment"># theta=-pi,</span></span><br><span class="line">                        qlim=[-<span class="number">350</span> * deg, <span class="number">350</span> * deg]</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">        L = [L1, L2, L3, L4, L5, L6]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create SerialLink object</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(</span><br><span class="line">            L,</span><br><span class="line">            <span class="comment"># meshdir=&quot;KUKA/KR5_arc&quot;,</span></span><br><span class="line">            name=<span class="string">&#x27;KR60&#x27;</span>,</span><br><span class="line">            manufacturer=<span class="string">&#x27;KUKA&#x27;</span>)</span><br><span class="line">            <span class="comment"># meshdir=&quot;meshes/KUKA/KR60_arc&quot;)</span></span><br><span class="line"></span><br><span class="line">        self.addconfiguration(<span class="string">&quot;qz&quot;</span>, [<span class="number">0</span>, -pi/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, pi])</span><br><span class="line">        self.addconfiguration(</span><br><span class="line">          <span class="string">&quot;qk1&quot;</span>, [<span class="number">0</span>, -pi/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        self.addconfiguration(</span><br><span class="line">          <span class="string">&quot;qk2&quot;</span>, [pi / <span class="number">4</span>, pi / <span class="number">3</span>, pi / <span class="number">6</span>, pi / <span class="number">3</span>, pi / <span class="number">4</span>, pi / <span class="number">6</span>])</span><br><span class="line">        self.addconfiguration(</span><br><span class="line">          <span class="string">&quot;qk3&quot;</span>, [pi / <span class="number">6</span>, pi / <span class="number">3</span>, pi / <span class="number">6</span>, pi / <span class="number">3</span>, pi / <span class="number">6</span>, pi / <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:   <span class="comment"># pragma nocover</span></span><br><span class="line">    robot = KR60()</span><br><span class="line">    <span class="built_in">print</span>(robot)</span><br></pre></td></tr></table></figure>
<p>在主程序中调用建模程序，同时对实际角度进行相应的转换，转换为D-H模型中对应的关节角进行运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> roboticstoolbox <span class="keyword">as</span> rtb</span><br><span class="line"><span class="keyword">from</span> spatialmath <span class="keyword">import</span> SE3</span><br><span class="line"><span class="keyword">from</span> spatialmath.base <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> KR60</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thetaTrans</span>(<span class="params">q</span>):</span><br><span class="line">    q[<span class="number">0</span>] = -q[<span class="number">0</span>]</span><br><span class="line">    q[<span class="number">1</span>] = q[<span class="number">1</span>]</span><br><span class="line">    q[<span class="number">2</span>] = q[<span class="number">2</span>] - pi / <span class="number">2</span></span><br><span class="line">    q[<span class="number">3</span>] = -q[<span class="number">3</span>]</span><br><span class="line">    q[<span class="number">4</span>] = q[<span class="number">4</span>]</span><br><span class="line">    q[<span class="number">5</span>] = pi - q[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line">q = [-<span class="number">2.410000</span> / <span class="number">180</span> * pi, -<span class="number">57.230000</span> / <span class="number">180</span> * pi, <span class="number">112.080000</span> / <span class="number">180</span> * pi, -<span class="number">0.780000</span> / <span class="number">180</span> * pi, -<span class="number">54.890000</span> / <span class="number">180</span> * pi,</span><br><span class="line">     <span class="number">1.440000</span> / <span class="number">180</span> * pi]</span><br><span class="line">q = thetaTrans(q)</span><br><span class="line"><span class="built_in">print</span>(q)</span><br><span class="line"></span><br><span class="line">robot = KR60.KR60()</span><br><span class="line">T = robot.fkine(q)  </span><br><span class="line"><span class="built_in">print</span>(T)</span><br><span class="line">T.printline()</span><br></pre></td></tr></table></figure>
<p>得到的结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0.04206243497306334, -0.9988519309163547, 0.38536869884034797, 0.01361356816555577, -0.9580112264196875, 3.1164599123610746]</span><br><span class="line">   0.001189 -0.03091   0.9995    1.569     </span><br><span class="line">  -0.01727   0.9994    0.03092   0.06416   </span><br><span class="line">  -0.9999   -0.01729   0.0006545  0.9428    </span><br><span class="line">   0         0         0         1         </span><br><span class="line"></span><br><span class="line">t = 1.57, 0.0642, 0.943; rpy/zyx = -87.8°, 89°, -86.1°</span><br></pre></td></tr></table></figure>
<h3 id="spatialmath-python库">（3）<strong><a
target="_blank" rel="noopener" href="https://github.com/petercorke/spatialmath-python">spatialmath-python</a></strong>库</h3>
<h4 id="函数说明">1.函数说明</h4>
<p>spatialmath-python库提供了旋转角度，旋转矩阵，四元素，变换矩阵之间的转换函数。</p>
<p>例如，我们可以创建一个刚体变换，它是围绕 x 轴旋转 30 度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spatialmath.base <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rotx(<span class="number">30</span>, <span class="string">&#x27;deg&#x27;</span>)</span><br><span class="line">array([[ <span class="number">1.</span>   ,  <span class="number">0.</span>   ,  <span class="number">0.</span>   ],</span><br><span class="line">       [ <span class="number">0.</span>   ,  <span class="number">0.866</span>, -<span class="number">0.5</span>  ],</span><br><span class="line">       [ <span class="number">0.</span>   ,  <span class="number">0.5</span>  ,  <span class="number">0.866</span>]])</span><br></pre></td></tr></table></figure>
<p>这将导致一个
NumPy（4x4）数组，该数组属于组（SE3）。我们还可以创建一个类实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from spatialmath import *</span><br><span class="line">&gt;&gt;&gt; T = SE3.Rx(30, &#x27;deg&#x27;)</span><br><span class="line">&gt;&gt;&gt; type(T)</span><br><span class="line">&lt;class &#x27;spatialmath.pose3d.SE3&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; print(T)</span><br><span class="line">   1         0         0         0         </span><br><span class="line">   0         0.866    -0.5       0         </span><br><span class="line">   0         0.5       0.866     0         </span><br><span class="line">   0         0         0         1  </span><br></pre></td></tr></table></figure>
<p>它在内部表示为4*4 NumPy 数组。</p>
<p>虽然函数和类可以提供类似的功能，但该类具有以下优点：</p>
<ul>
<li>类型安全，不可能将3D旋转矩阵与2D刚体运动混合，即使两者都由3*3矩阵表示</li>
<li>运算符重载允许方便和可读的算法表达</li>
<li>表示的不仅仅是单个值，而是一系列值，这些值由运算符通过隐式广播值进行处理</li>
</ul>
<h4 id="spatial-math-类">2.Spatial math 类</h4>
<p>如上述所表示的SO3类R,可以计算出相应的欧拉角</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; R.eul()</span><br></pre></td></tr></table></figure>
<p>在机器人技术中，我们经常需要一个序列，一个轨迹，旋转矩阵或姿势。这些姿势类从类继承功能<code>list</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = SO3()   <span class="comment"># the identity</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R.append(R1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R.append(R2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(R)</span><br><span class="line"> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R[<span class="number">1</span>]</span><br><span class="line">   <span class="number">1</span>         <span class="number">0</span>         <span class="number">0</span>          </span><br><span class="line">   <span class="number">0</span>         <span class="number">0.955336</span> -<span class="number">0.29552</span>    </span><br><span class="line">   <span class="number">0</span>         <span class="number">0.29552</span>   <span class="number">0.955336</span>             </span><br></pre></td></tr></table></figure>
<p>这可以在循环和列表理解中使用<code>for</code></p>
<p>构造它的另一种方法是（在上面定义的<code>R1 R2</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = SO3( [ SO3(), R1, R2 ] )       </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(R)</span><br><span class="line"> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>许多构造函数支持矢量化，例如 <code>.Rx</code>, <code>.Ry</code> and
<code>.Rz</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = SO3.Rx( np.arange(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">0.2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(R)</span><br><span class="line"> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>它在一行中创建了旋转矩阵列表。</p>
<p>矢量化也适用于运算符，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = R * SO3.Ry(0.5)</span><br><span class="line">&gt;&gt;&gt; len(R)</span><br><span class="line"> 32</span><br></pre></td></tr></table></figure>
<p>将产生一个结果，其中每个元素都是左侧与右侧的每个元素的乘积，即。
<code>R[i] * SO3.Ry(0.5)</code>.</p>
<p>同样地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = SO3.Ry(0.5) * R </span><br><span class="line">&gt;&gt;&gt; len(R)</span><br><span class="line"> 32</span><br></pre></td></tr></table></figure>
<p>将产生一个结果，其中每个元素都是左侧的乘积，即右侧的每个元素。.<code>SO3.Ry(0.5) * R[i]</code></p>
<p>最后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = R * R </span><br><span class="line">&gt;&gt;&gt; len(R)</span><br><span class="line"> 32</span><br></pre></td></tr></table></figure>
<p>将产生一个结果，其中每个元素是左侧每个元素与右侧每个元素的乘积，即。.<code>R[i] * R[i]</code></p>
<p>这些类的基础表示是一个 numpy
矩阵，但该类确保该矩阵的结构对于所表示的特定类有效：SO（2）、SE（2）、SO（3）、SE（3）。任何对类无效的操作都将返回矩阵而不是
pose 类，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; SO3.Rx(0.3) * 2</span><br><span class="line">array([[ 2.        ,  0.        ,  0.        ],</span><br><span class="line">       [ 0.        ,  1.91067298, -0.59104041],</span><br><span class="line">       [ 0.        ,  0.59104041,  1.91067298]])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; SO3.Rx(0.3) - 1</span><br><span class="line">array([[ 0.        , -1.        , -1.        ],</span><br><span class="line">       [-1.        , -0.04466351, -1.29552021],</span><br><span class="line">       [-1.        , -0.70447979, -0.04466351]])</span><br></pre></td></tr></table></figure>
<p>我们也可以打印和打印这些对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; T = SE3(1,2,3) * SE3.Rx(30, &#x27;deg&#x27;)</span><br><span class="line">&gt;&gt;&gt; T.print()</span><br><span class="line">   1         0         0         1          </span><br><span class="line">   0         0.866025 -0.5       2          </span><br><span class="line">   0         0.5       0.866025  3          </span><br><span class="line">   0         0         0         1          </span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; T.printline()</span><br><span class="line">t =        1,        2,        3; rpy/zyx =       30,        0,        0 deg</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; T.plot()</span><br></pre></td></tr></table></figure>
<h1 id="二vrep与python">二、VREP与PYTHON</h1>
<h2 id="建立urdf模型">1.建立URDF模型</h2>
<p>准备工作：下载solidworks导出urdf文件的插件：http://wiki.ros.org/sw_urdf_exporter
，下载直接安装即可。</p>
<ol type="1">
<li><p>去库卡官网下载KR60-3的STL模型</p></li>
<li><p>按照面重合-轴线重合的方式，装配好机器人模型。</p></li>
<li><p>在装配体中编辑零件，提取关节基准轴，以第六轴为例，命名为axis_6</p></li>
<li><p>对各关节建立起相应的轴线之后，退出零件编辑，返回装配体设置，对基座、关节以及刀具建立坐标系，注意所建立的坐标系不能在零件的内部，必须在装配体的树形目录下，坐标系的Z轴指向关节旋转方向。</p></li>
<li><p>点击工具-tool-export as
URDF,轴和坐标系之前建立的关节轴线和坐标轴，零件选择相应的杆件，轴的类型都选择旋转副。</p></li>
<li><p>导出URDF文件，在最后的配置文件中可以调整杆件的颜色</p></li>
</ol>
<h2 id="导入vrep">2.导入VREP</h2>
<ol type="1">
<li><p>在Vrep中，Plugins-URDF
export导入模型文件，注意导入路径不能有中文，否则导入会失败。</p></li>
<li><p>将基座设置为固定，调整相应的杆件关节极限,运动模式修改为Torque/force
mode。进一步修改杆件的动力学信息，使能电动机，将电动机的最大力矩调整为合适的大小，打开control
position
enable，修改关节速度极限，这样就可以在脚本中修改关节数据，使机器人按我们设定的轨迹运动。</p></li>
<li><p>添加运动脚本，ADD-Associated child scripts-no thread
scripts。</p>
<p>API解释见：<a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/apiFunctions.htm">regular
API reference (coppeliarobotics.com)</a></p>
<p>Lua脚本分为4部分，包含由系统适当调用的回调函数集合。除了初始化回调之外，所有其他回调都是可选的。默认主脚本通常分为4个回调函数：</p>
<p>初始化函数：sysCall_init（）。此回调函数不是可选的。它将在模拟开始时执行一次。代码负责准备模拟等。通过sim.getObjectHandle函数初始化各关节的句柄</p>
<p>驱动函数：sysCall_actuation()。此回调函数将在每次模拟过程中执行。代码负责处理模拟的所有驱动功能。有一个函数特别有趣：sim.HandleChildScript，它调用子脚本的系统调用回调函数。如果没有这些命令，子脚本将无法执行或无法执行其驱动功能，特定的模型功能或行为也无法按预期运行。</p>
<p>传感函数：sysCall_sensing()。此回调函数将在每次模拟过程中执行。代码负责以通用方式处理模拟的所有传感功能（接近传感器等）。同样也有sim.HandleChildScript，它调用子脚本的系统调用回调函数。</p>
<p>恢复函数：sysCall_cleanup()。此函数将在模拟结束前执行一次。该代码负责恢复对象的初始配置、清除传感器状态等。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sysCall_init</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- do some initialization here</span></span><br><span class="line">    axis_1_handle = sim.getObjectHandle(<span class="string">&#x27;axis_1&#x27;</span>)</span><br><span class="line">    axis_2_handle = sim.getObjectHandle(<span class="string">&#x27;axis_2&#x27;</span>)</span><br><span class="line">    axis_3_handle = sim.getObjectHandle(<span class="string">&#x27;axis_3&#x27;</span>)</span><br><span class="line">    axis_4_handle = sim.getObjectHandle(<span class="string">&#x27;axis_4&#x27;</span>)</span><br><span class="line">    axis_5_handle = sim.getObjectHandle(<span class="string">&#x27;axis_5&#x27;</span>)</span><br><span class="line">    axis_6_handle = sim.getObjectHandle(<span class="string">&#x27;axis_6&#x27;</span>)</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--graph</span></span><br><span class="line">    graph=sim.getObjectHandle(<span class="string">&#x27;Graph&#x27;</span>)</span><br><span class="line">    JointPos=sim.getObjectHandle(<span class="string">&#x27;JointPos&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    objectPosX=sim.addGraphStream(graph,<span class="string">&#x27;object pos x&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    objectPosY=sim.addGraphStream(graph,<span class="string">&#x27;object pos y&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    objectPosZ=sim.addGraphStream(graph,<span class="string">&#x27;object pos Z&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    objectJoint1=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint1&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;)</span><br><span class="line">    objectJoint2=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint2&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0</span>&#125;)</span><br><span class="line">    objectJoint3=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint3&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;)</span><br><span class="line">    objectJoint4=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint4&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0.5</span>&#125;)</span><br><span class="line">    objectJoint5=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint5&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;)</span><br><span class="line">    objectJoint6=sim.addGraphStream(JointPos,<span class="string">&#x27;Joint6&#x27;</span>,<span class="string">&#x27;deg/s&#x27;</span>,<span class="number">0</span>,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;)</span><br><span class="line">    </span><br><span class="line">    objectTime=sim.addGraphStream(JointPos,<span class="string">&#x27;Time&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    sim.addGraphCurve(graph,<span class="string">&#x27;object pos x/y/z&#x27;</span>,<span class="number">3</span>,&#123;objectPosX,objectPosY,objectPosZ&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="string">&#x27;m by m&#x27;</span>)</span><br><span class="line">    sim.addGraphCurve(JointPos,<span class="string">&#x27;Joint1&#x27;</span>,<span class="number">2</span>,&#123;objectJoint1,objectTime&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,<span class="string">&#x27;m by m&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--base frame</span></span><br><span class="line">    base_frame = sim.getObjectHandle(<span class="string">&#x27;baseframe&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sysCall_actuation</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- put your actuation code here</span></span><br><span class="line">    </span><br><span class="line">    t = t + <span class="number">0.01</span></span><br><span class="line">    <span class="comment">--print(t)</span></span><br><span class="line">    </span><br><span class="line">    axis_1_angle = sim.getJointPosition(axis_1_handle)</span><br><span class="line">    axis_2_angle = sim.getJointPosition(axis_2_handle)</span><br><span class="line">    axis_3_angle = sim.getJointPosition(axis_3_handle)</span><br><span class="line">    axis_4_angle = sim.getJointPosition(axis_4_handle)</span><br><span class="line">    axis_5_angle = sim.getJointPosition(axis_5_handle)</span><br><span class="line">    axis_6_angle = sim.getJointPosition(axis_6_handle)</span><br><span class="line">   </span><br><span class="line">    axis_1_targetAngle = <span class="built_in">math</span>.<span class="built_in">pi</span> / <span class="number">3</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    axis_2_targetAngle = -<span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">2</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    axis_3_targetAngle = <span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">2</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    axis_4_targetAngle = <span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">4</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    axis_5_targetAngle = <span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">6</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    axis_6_targetAngle = <span class="built_in">math</span>.<span class="built_in">pi</span>/<span class="number">5</span> * <span class="built_in">math</span>.<span class="built_in">sin</span>(t)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--print(180*sim.getJointPosition(axis_6_handle)/math.pi)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">--print(180*sim.getJointPosition(axis_1_handle)/math.pi)</span></span><br><span class="line">    <span class="comment">--print(axis_1_targetAngle)</span></span><br><span class="line">    sim.setJointTargetPosition(axis_1_handle,axis_1_targetAngle)</span><br><span class="line">    sim.setJointTargetPosition(axis_2_handle,axis_2_targetAngle)</span><br><span class="line">    sim.setJointTargetPosition(axis_3_handle,axis_3_targetAngle)</span><br><span class="line">    sim.setJointTargetPosition(axis_4_handle,axis_4_targetAngle)</span><br><span class="line">    sim.setJointTargetPosition(axis_5_handle,axis_5_targetAngle)</span><br><span class="line">    sim.setJointTargetPosition(axis_6_handle,axis_6_targetAngle)</span><br><span class="line">    <span class="comment">--print(axis_1_angle)</span></span><br><span class="line">    <span class="comment">--print(axis_2_angle)</span></span><br><span class="line">    <span class="comment">--print(axis_2_targetAngle)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sysCall_sensing</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- put your sensing code here</span></span><br><span class="line">    <span class="keyword">local</span> pos=sim.getObjectPosition(graph,<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">--print(pos)</span></span><br><span class="line">    </span><br><span class="line">    sim.setGraphStreamValue(graph,objectPosX,pos[<span class="number">1</span>])</span><br><span class="line">    sim.setGraphStreamValue(graph,objectPosY,pos[<span class="number">2</span>])</span><br><span class="line">    sim.setGraphStreamValue(graph,objectPosZ,pos[<span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint1,<span class="number">180</span>*sim.getJointPosition(axis_1_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint2,<span class="number">180</span>*sim.getJointPosition(axis_2_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint3,<span class="number">180</span>*sim.getJointPosition(axis_3_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint4,<span class="number">180</span>*sim.getJointPosition(axis_4_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint5,<span class="number">180</span>*sim.getJointPosition(axis_5_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    sim.setGraphStreamValue(JointPos,objectJoint6,<span class="number">180</span>*sim.getJointPosition(axis_6_handle)/<span class="built_in">math</span>.<span class="built_in">pi</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">--Joint1=&#123;&#125;</span></span><br><span class="line">    <span class="comment">--table.insert(Joint1,axis_1_angle)</span></span><br><span class="line">    <span class="comment">--sim.setGraphStreamValue(JointPos,objectJoint1,Joint1)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sysCall_cleanup</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- do some clean-up here</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- See the user manual or the available code snippets for additional callback functions and details</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>点击仿真进行按钮，机器人就按着脚本中关节设置的轨迹进行移动，同时在空间中绘制出末端的运行轨迹，在弹出的框中也可以看到末端在XY平面的轨迹。</li>
</ol></li>
</ol>
<h2 id="联合仿真">3.联合仿真</h2>
<p>Vrep提供了三种远程api，远程API是应用程序与CoppeliaSim连接的几种方式之一。它允许CoppeliaSim和外部应用程序（即在不同进程或不同机器上运行的应用程序）之间的通信，是跨平台的，支持服务调用（即阻塞调用），还支持双向数据流。它有三种不同的版本/框架：</p>
<p><a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/zmqRemoteApiOverview.htm">The
ZeroMQ-based remote
API</a>：它轻量级且易于使用，提供了通过CoppeliaSim脚本也可用的所有API函数，目前支持Python客户端。</p>
<p><a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">The
legacy remote API</a> (or simply <em>remote
API</em>)：它相对轻量级，并且比基于B0的远程API具有更少的依赖性。它提供了API函数的子集，并支持以下客户端：C/C++、Java、Python、Matlab、Octave和Lua。</p>
<p><a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">The
B0-based remote
API</a>：它基于BlueZero中间件及其与CoppeliaSim的接口插件。它提供了API函数的子集，可以很容易地扩展和支持以下客户端：C++、java、python、Matlab和Lua。</p>
<h3 id="vrep与matlab联合仿真">1.Vrep与matlab联合仿真</h3>
<h4 id="legacy-remote-api"><a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">Legacy
remote API</a></h4>
<p>要在Matlab程序中使用远程API功能，需要以下3项：</p>
<ul>
<li><p>remoteApiProto.m</p></li>
<li><p>remApi.m</p></li>
<li><p>remoteApi.dll</p>
<ul>
<li><p>新建一个matlab项目文件夹</p></li>
<li><p>将C:Files。</p></li>
<li><p>转到C:Files，调整类型只显示应用程序拓展，全选所有的DLL文件，拷贝到matlab文件夹。</p></li>
<li><p>remoteapi.dll在C:Files，同样拷贝到项目文件夹</p></li>
<li><p>打开matlab，将项目文件夹包含到预定路径中，使程序在运行中能调用相应的函数和dll文件。</p></li>
</ul></li>
</ul>
<p>在Matlab的当前文件夹中包含上述文件后，调用sim=remApi（'remoteApi'）来构建对象并加载库。要在客户端（即您的应用程序）启用远程API，请调用sim.simxStart。请参阅simpleTest。以编程/remoteApiBindings/matlab目录中的m程序为例。本页列出并描述所有支持的Matlab远程API函数。CoppeliaSim远程API函数可以很容易地从它们的“simx”前缀中识别出来。
确保您的Matlab使用与remoteApi库相同的位体系结构：64位Matlab和32位remoteApi库将无法工作，反之亦然！</p>
<p>关键的语句</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V-REP端：</span><br><span class="line">simExtRemoteApiStart(<span class="number">19999</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATLAB端：</span><br><span class="line">vrep=remApi(<span class="string">&#x27;remoteApi&#x27;</span>); <span class="comment">% using the prototype file (remoteApiProto.m)</span></span><br><span class="line">vrep.simxFinish(<span class="number">-1</span>); <span class="comment">% just in case, close all opened connections</span></span><br><span class="line">clientID=vrep.simxStart(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">19999</span>,<span class="built_in">true</span>,<span class="built_in">true</span>,<span class="number">5000</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="b0-based-remote-api"><a
target="_blank" rel="noopener" href="https://coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based
remote API</a></h4>
<h5 id="python">python</h5>
<ol type="1">
<li><h6
id="要在python脚本中使用基于b0的远程api功能您需要以下内容">要在Python脚本中使用基于B0的远程API功能，您需要以下内容：</h6></li>
</ol>
<ul>
<li>安装用于Python的MessagePack:<code>pip install msgpack</code></li>
<li><em>C:FilesRemoteApiBindingsRemoteApi.py</em></li>
<li>C:FilesRemoteApiBindings.py。</li>
<li>blueZero库（例如b0.dll），不要忘记blueZero库本身有依赖项（例如<em>libzmq</em>,
<em>boost_chrono</em>, <em>boost_system</em>,
<em>boost_thread</em>等）。</li>
</ul>
<ol start="2" type="1">
<li><h6 id="创建anaconda虚拟环境">创建anaconda虚拟环境</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、用conda创建Python虚拟环境（在conda prompt环境下完成）</span><br><span class="line">conda create -n Vrep python=3.7</span><br><span class="line"></span><br><span class="line">2、激活虚拟环境（在conda prompt环境下完成）</span><br><span class="line">activate Vrep</span><br><span class="line"></span><br><span class="line">3、给虚拟环境安装外部包</span><br><span class="line">conda install -n Vrep [package]</span><br><span class="line">例如: conda install -n tensorflow pandas</span><br><span class="line"></span><br><span class="line">4、查看已有的环境(当前已激活的环境会显示一个星号)</span><br><span class="line">conda info -e</span><br><span class="line"></span><br><span class="line">5、删除一个已有的虚拟环境</span><br><span class="line">conda remove --name your_env_name --all</span><br><span class="line"></span><br><span class="line">6、查看pip的安装目录</span><br><span class="line">pip list</span><br><span class="line"></span><br><span class="line">7、删除已经安装的模块</span><br><span class="line">pip uninstall **</span><br><span class="line">(例如：pip uninstall numpy)</span><br></pre></td></tr></table></figure>
<p>创建anaconda的虚拟环境后，会生成E:，在Pycharm中选择创建的虚拟环境。</p>
<ol start="3" type="1">
<li><p>和matlab操作一样，打开C:Files，调整类型只显示应用程序拓展，全选所有的DLL文件，拷贝到anaconda创建的虚拟环境的文件夹中。b0RemoteApi.py，b0.py拷贝到项目文件夹中，在pycharm控制台中使用，<code>conda install msgpack</code>下载msgpack包</p></li>
<li><p>打开Vrep端的服务器，直接在model browser中打开tools文件夹，将B0
Remote API Server拖动到场景中，就打开了Vrep端的服务器</p></li>
<li><p>打开python端的服务器</p></li>
</ol></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> b0RemoteApi</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> b0RemoteApi.RemoteApiClient(<span class="string">&#x27;b0RemoteApi_pythonClient&#x27;</span>,<span class="string">&#x27;b0RemoteApi&#x27;</span>) <span class="keyword">as</span> client:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getJointPos</span>(<span class="params">num</span>):</span><br><span class="line">        jointname = <span class="string">&quot;axis_&quot;</span> + <span class="built_in">str</span>(num)</span><br><span class="line">        [<span class="built_in">bool</span>, jointhandle] = client.simxGetObjectHandle(jointname, client.simxServiceCall())</span><br><span class="line">        [<span class="built_in">bool</span>, joint] = client.simxGetJointPosition(jointhandle, client.simxServiceCall())</span><br><span class="line">        <span class="built_in">print</span>(joint)</span><br><span class="line">        <span class="keyword">return</span> joint</span><br><span class="line">    client.simxStartSimulation(client.simxServiceCall()) <span class="comment">#开始仿真</span></span><br><span class="line">    startTime = time.time()</span><br><span class="line">    getJointPos(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; startTime + <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    client.simxStopSimulation(client.simxServiceCall()) <span class="comment">#停止仿真</span></span><br></pre></td></tr></table></figure>
<h5 id="基于b0的远程api操作方法">基于B0的远程API操作方法</h5>
<p>大多数基于B0的远程API函数需要一个附加参数：用于执行函数调用的主题或通信通道。</p>
<p>主题可以是以下5个函数之一的返回值：
<strong>simxServiceCall：</strong>本主题允许在阻塞模式下执行功能，即命令将传输到服务器（即CoppeLisim），在那里执行，并向客户端返回响应。仅当<strong>作为一次性操作</strong>从服务器获取命令响应时（例如，simxGetObjectHandle通常使用服务调用来执行）才使用此主题。
<strong>simxDefaultPublisher</strong>：本主题允许在非阻塞模式下执行函数，即函数被发送到服务器（即CoppeliaSim），控制权立即返回到客户端（即客户端不会等待服务器的回复）。<strong>仅在向服务器发送命令时使用此主题，您不希望/不需要服务器响应</strong>（例如，simxSetJointPosition通常使用默认发布服务器执行）。
<strong>simxDefaultSubscriber</strong>：本主题通知服务器<strong>持续执行该函数，并持续将响应流式传输到客户端</strong>。客户端将在回调函数中接收响应。仅当您希望从服务器端连续执行的同一命令接收响应时，才使用此主题。（例如，simxGetJointForce通常使用默认订阅服务器执行）。定义的回调函数通过simxSpinOnce函数调用（当输入缓冲区中有响应可用时）。
<strong>simxCreatePublisher</strong>：这与simxDefaultPublisher非常相似，不同之处在于创建了一个<strong>专用的发布者主题</strong>，即创建了一个专用的发布频道。将特定功能/命令分配给专用发布服务器非常有用，特别是在数据量大的情况下（例如，simxSetVisionSensorImage通常使用专用发布服务器执行）。
<strong>simxCreateSubscriber</strong>：这与simxDefaultSubscriber非常相似，不同之处在于创建了专用订户主题，即创建了<strong>专用订户频道</strong>。将特定功能/命令分配给专用订阅者可能很有用，特别是在数据量大的情况下（例如，simxGetVisionSensorImage通常使用专用订阅者来执行）。
默认情况下，基于B0的远程API客户端和服务器（即CoppeliaSim）将异步运行。但是，为了实现同步操作，可以让客户端单独触发每个模拟步骤。以下是同步模式的Python示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> b0RemoteApi</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> b0RemoteApi.RemoteApiClient(<span class="string">&#x27;b0RemoteApi_pythonClient&#x27;</span>,<span class="string">&#x27;b0RemoteApi&#x27;</span>) <span class="keyword">as</span> client:    </span><br><span class="line">    doNextStep=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">simulationStepStarted</span>(<span class="params">msg</span>):</span><br><span class="line">        simTime=msg[<span class="number">1</span>][<span class="string">b&#x27;simulationTime&#x27;</span>];</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Simulation step started. Simulation time: &#x27;</span>,simTime)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">simulationStepDone</span>(<span class="params">msg</span>):</span><br><span class="line">        simTime=msg[<span class="number">1</span>][<span class="string">b&#x27;simulationTime&#x27;</span>];</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Simulation step done. Simulation time: &#x27;</span>,simTime);</span><br><span class="line">        <span class="keyword">global</span> doNextStep</span><br><span class="line">        doNextStep=<span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    client.simxSynchronous(<span class="literal">True</span>)</span><br><span class="line">    client.simxGetSimulationStepStarted(client.simxDefaultSubscriber(simulationStepStarted));</span><br><span class="line">    client.simxGetSimulationStepDone(client.simxDefaultSubscriber(simulationStepDone));</span><br><span class="line">    client.simxStartSimulation(client.simxDefaultPublisher())</span><br><span class="line">    </span><br><span class="line">    startTime=time.time()</span><br><span class="line">    <span class="keyword">while</span> time.time()&lt;startTime+<span class="number">5</span>: </span><br><span class="line">        <span class="keyword">if</span> doNextStep:</span><br><span class="line">            doNextStep=<span class="literal">False</span></span><br><span class="line">            client.simxSynchronousTrigger()</span><br><span class="line">        client.simxSpinOnce()</span><br><span class="line">    client.simxStopSimulation(client.simxDefaultPublisher())</span><br></pre></td></tr></table></figure>
<h1 id="三仿真">三、仿真</h1>
<h1 id="四python小知识">四、python小知识</h1>
<h2 id="创建anaconda虚拟环境-1">1.创建anaconda虚拟环境</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、用conda创建Python虚拟环境（在conda prompt环境下完成）</span><br><span class="line">conda create -n Vrep python=3.7</span><br><span class="line"></span><br><span class="line">2、激活虚拟环境（在conda prompt环境下完成）</span><br><span class="line">activate Vrep</span><br><span class="line"></span><br><span class="line">3、给虚拟环境安装外部包</span><br><span class="line">conda install -n Vrep [package]</span><br><span class="line">例如: conda install -n tensorflow pandas</span><br><span class="line"></span><br><span class="line">4、查看已有的环境(当前已激活的环境会显示一个星号)</span><br><span class="line">conda info -e</span><br><span class="line"></span><br><span class="line">5、删除一个已有的虚拟环境</span><br><span class="line">conda remove --name your_env_name --all</span><br><span class="line"></span><br><span class="line">6、查看pip的安装目录</span><br><span class="line">pip list</span><br><span class="line"></span><br><span class="line">7、删除已经安装的模块</span><br><span class="line">pip uninstall **</span><br><span class="line">(例如：pip uninstall numpy)</span><br></pre></td></tr></table></figure>
<p>创建anaconda的虚拟环境后，会生成E:，在Pycharm中选择创建的虚拟环境。</p>
<h2 id="pip换镜像源">2.pip换镜像源</h2>
<p>在 python 里经常要安装各种这样的包，安装各种包时最常用的就是 pip，pip
默认从官网下载文件，官网位于国外，下载速度时快时慢，还经常断线，国内的体验并不太好。</p>
<p>解决办法是把 pip
源换成国内的，最常用的并且可信赖的源包括清华大学源、豆瓣源、阿里源：</p>
<blockquote>
<p>pypi 清华大学源：<a
href="https://link.zhihu.com/?target=https%3A//pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a>
pypi 豆瓣源 ：<a
href="https://link.zhihu.com/?target=http%3A//pypi.douban.com/simple/">http://pypi.douban.com/simple/</a>
pypi 腾讯源：<a
href="https://link.zhihu.com/?target=http%3A//mirrors.cloud.tencent.com/pypi/simple">http://mirrors.cloud.tencent.com/pypi/simple</a>
pypi 阿里源：<a
href="https://link.zhihu.com/?target=https%3A//mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi</a></p>
</blockquote>
<p>pip 源具体修改方式是，我们以安装 python
的robotics-toolbox-python模块为例，通常的方式是直接在命令行运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install robotics-toolbox-python</span><br></pre></td></tr></table></figure>
<p>这样会从国外官网下载robotics-toolbox-python模块并安装。</p>
<p>若要把 pip
源换成国内的，只需要把上面的代码改成下图这样（下图以清华大学源为例）：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install robotics-toolbox-python -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>这样我们就从清华大学源成功安装了机器人工具箱，速度会比过pip默认的国外源快很多。</p>
<p>上述做法是临时改成国内源，如果不想每次用 pip 都加上
<code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code>，那么可以把国内源设为默认，做法是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># 阿里源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"><span class="comment"># 腾讯源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line"><span class="comment"># 豆瓣源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/typora%E5%85%AC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/typora%E5%85%AC%E5%BC%8F/" itemprop="url">typora公式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="markdown公式">Markdown公式</h1>
<h2 id="公式块">1.公式块</h2>
<ul>
<li><p><strong>创建独立的一块公式区域</strong>。</p></li>
<li><p>上部分为公式输入区</p></li>
<li><p>下部分为效果展示区</p></li>
</ul>
<p>编辑别处时展示效果图。</p>
<p><strong>方法一</strong>：左上角点击“段落”，再点击“公式块”</p>
<p><strong>方法一</strong>：在文中输入$$，再按下回车</p>
<h3 id="行内公式">2.行内公式</h3>
<ul>
<li><strong>将公式嵌入文字内</strong>。</li>
</ul>
<p><strong>方法一</strong>： 在$$的中间加入需要的公式</p>
<p><strong>简便的方法一</strong>：先按 $ ，再按 “esc”（键盘左上角）</p>
<p>（行内公式是需要先设置一下）</p>
<hr />
<h2 id="常用符号的代码">常用符号的代码</h2>
<ul>
<li>上下标，正负无穷</li>
<li>加减乘，分式，根号，省略号</li>
<li>三角函数</li>
<li>矢量，累加累乘，极限</li>
<li>希腊字母</li>
</ul>
<h3 id="上下标正负无穷"><strong>1.上下标，正负无穷</strong></h3>
<h3
id="加减乘分式根号省略号"><strong>2.加减乘，分式，根号，省略号</strong></h3>
<h3 id="三角函数"><strong>3.三角函数</strong></h3>
<h3 id="矢量累加累乘极限"><strong>4.矢量，累加累乘，极限</strong></h3>
<h3 id="希腊字母"><strong>5.希腊字母</strong></h3>
<h3 id="关系运算符"><strong>6.关系运算符</strong></h3>
<h3 id="积分">7.积分</h3>
<h3 id="求导">8.求导</h3>
<h4 id="求导-1">(1）求导</h4>
<p><span class="math display">\[
\frac{df(\theta)}{d\theta}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac&#123;df(\theta)&#125;&#123;d\theta&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h4 id="求偏导">(2) 求偏导</h4>
<p><span class="math display">\[
\frac {\partial Loss } {\partial C }
\]</span></p>
<hr />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\frac &#123;\partial Loss &#125; &#123;\partial C &#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h2 id="矩阵"><strong>矩阵</strong></h2>
<h3 id="简单矩阵"><strong>1.简单矩阵</strong></h3>
<p>使用<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code>生成，
每一行以<code>\\</code>结尾表示换行，元素间以<code>&amp;</code>间隔，式子的表示序号<code>\tag&#123;1&#125;</code>（右边的序号）。</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190701327.png" class="" title="image-20220824190701327">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> $$</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line"> 1 &amp; 2 &amp; 3 \\</span><br><span class="line"> 4 &amp; 5 &amp; 6 \\</span><br><span class="line"> 7 &amp; 8 &amp; 9 </span><br><span class="line">\end&#123;matrix&#125; \tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h3
id="带左右括号的矩阵大中小括号"><strong>2.带左右括号的矩阵(大中小括号)</strong></h3>
<p><strong>方法一</strong>：在<code>\begin&#123;&#125;</code>之前和<code>\end&#123;&#125;</code>之后添加左右括号的代码。</p>
<p>大括号：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190626549.png" class="" title="image-20220824190626549">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \left\&#123;</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">  \right\&#125; \tag&#123;2&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>中括号：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190648321.png" class="" title="image-20220824190648321">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \left[</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">  \right] \tag&#123;3&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>小括号：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190713543.png" class="" title="image-20220824190713543">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \left(</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;matrix&#125;</span><br><span class="line">  \right) \tag&#123;4&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong>：改变<code>\begin&#123;matrix&#125;</code>和<code>\end&#123;matrix&#125;</code>中<code>&#123;matrix&#125;</code></p>
<p>大括号：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190720271.png" class="" title="image-20220824190720271">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \begin&#123;Bmatrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;Bmatrix&#125; \tag&#123;6&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>中括号：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190729413.png" class="" title="image-20220824190729413">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \begin&#123;bmatrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;bmatrix&#125; \tag&#123;6&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h3
id="包含希腊字母与省略号"><strong>3.包含希腊字母与省略号</strong></h3>
<p>行省略号<code>\cdots</code>，列省略号<code>\vdots</code>，斜向省略号（左上至右下）<code>\ddots</code>。</p>
<figure>
<img src="typora%E5%85%AC%E5%BC%8F/image-20220824190737732.png"
alt="[公式]" />
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \left\&#123;</span><br><span class="line"> \begin&#123;matrix&#125;</span><br><span class="line"> 1      &amp; 2        &amp; \cdots &amp; 5        \\</span><br><span class="line"> 6      &amp; 7        &amp; \cdots &amp; 10       \\</span><br><span class="line"> \vdots &amp; \vdots   &amp; \ddots &amp; \vdots   \\</span><br><span class="line"> \alpha &amp; \alpha+1 &amp; \cdots &amp; \alpha+4 </span><br><span class="line"> \end&#123;matrix&#125;</span><br><span class="line"> \right\&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="公式序号">公式序号</h2>
<p>见“矩阵”小节，代码最后的一行即表示右端序号</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">\tag&#123;6&#125;</span><br></pre></td></tr></table></figure>
<h2 id="行列式">行列式</h2>
<p>行列式相关语法与矩阵类似 <span class="math display">\[
\begin{vmatrix}
   1 &amp; 2 &amp; 3 \\
   4 &amp; 5 &amp; 6 \\
   7 &amp; 8 &amp; 9
  \end{vmatrix}
\tag{7}
\]</span></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line"> \begin&#123;vmatrix&#125;</span><br><span class="line">   1 &amp; 2 &amp; 3 \\</span><br><span class="line">   4 &amp; 5 &amp; 6 \\</span><br><span class="line">   7 &amp; 8 &amp; 9</span><br><span class="line">  \end&#123;vmatrix&#125;</span><br><span class="line">\tag&#123;7&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="表格">表格</h2>
<h3 id="简易表格"><strong>1.简易表格</strong></h3>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190751478.png" class="" title="image-20220824190751478">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;|c|c|c|&#125;</span><br><span class="line">	\hline 2&amp;9&amp;4\\</span><br><span class="line">	\hline 7&amp;5&amp;3\\</span><br><span class="line">	\hline 6&amp;1&amp;8\\</span><br><span class="line">	\hline</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p><strong>开头结尾</strong>： <code>\begin&#123;array&#125;</code> ，
<code>\end&#123;array&#125;</code></p>
<p><strong>定义式</strong>：例：<code>&#123;|c|c|c|&#125;</code>，其中<code>c</code>
<code>l</code> <code>r</code> 分别代表居中、左对齐及右对齐。</p>
<p><strong>分割线</strong>：①<strong>竖直分割线</strong>：在定义式中插入
<code>|</code>， （<code>||</code>表示两条竖直分割线）。</p>
<p>②<strong>水平分割线</strong>：在下一行输入前插入
<code>\hline</code>，以下图真值表为例。</p>
<p>其他：每行元素间均须要插入 <code>&amp;</code> ，每行元素以
<code>\\</code> 结尾。</p>
<h3 id="真值表"><strong>2..真值表</strong></h3>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190801129.png" class="" title="image-20220824190801129">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;array&#125;&#123;cc|c&#125;</span><br><span class="line">	       A&amp;B&amp;F\\</span><br><span class="line">	\hline 0&amp;0&amp;0\\</span><br><span class="line">	       0&amp;1&amp;1\\</span><br><span class="line">	       1&amp;0&amp;1\\</span><br><span class="line">	       1&amp;1&amp;1\\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="多行等式对齐"><strong>多行等式对齐</strong></h2>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190807817.png" class="" title="image-20220824190807817">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp;= b + c \\</span><br><span class="line">  &amp;= d + e + f</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<h2 id="方程组条件表达式"><strong>方程组、条件表达式</strong></h2>
<p>方程组：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190813676.png" class="" title="image-20220824190813676">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">3x + 5y +  z \\</span><br><span class="line">7x - 2y + 4z \\</span><br><span class="line">-6x + 3y + 2z</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>同理，条件表达式：</p>
<img src="/2022/08/24/typora%E5%85%AC%E5%BC%8F/image-20220824190823959.png" class="" title="image-20220824190823959">
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f(n) =</span><br><span class="line">\begin&#123;cases&#125; </span><br><span class="line">n/2,  &amp; \text&#123;if &#125;n\text&#123; is even&#125; \\</span><br><span class="line">3n+1, &amp; \text&#123;if &#125;n\text&#123; is odd&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="间隔-大小空格紧贴"><strong>间隔 (大小空格、紧贴)</strong></h2>
<p><strong>紧贴 + 无空格 + 小空格 + 中空格 + 大空格 + 真空格 +
双真空格</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">a\!b + ab + a\,b + a\;b + a\ b + a\quad b + a\qquad b</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>紧贴<code>\!</code></p>
<p>无空格 小空格<code>\,</code> 中空格<code>\;</code>
大空格<code>\</code></p>
<p>真空格<code>\quad</code> 双真空格<code>\qquad</code></p>
<hr />
<h2 id="通过python生成latex表达式">通过Python生成LaTeX表达式</h2>
<h3
id="step1安装latexify-py模块"><strong>step1：安装latexify-py模块</strong></h3>
<h3 id="step2编写代码"><strong>step2：编写代码</strong></h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import math				//引入数学模块(有些运算的函数需要)</span><br><span class="line">import latexify			//引入latexify模块</span><br><span class="line"></span><br><span class="line">@latexify.with_latex	//特定语法，表示之后定义的函数可以转化为LaTeX代码</span><br><span class="line">def f(x,y,z):		    //包含的参数</span><br><span class="line">    pass			   //此处填写可能需要的数学表达式</span><br><span class="line">    return result		//也可以直接体现数学关系</span><br><span class="line"></span><br><span class="line">print(f)			   //直接print(函数名)</span><br></pre></td></tr></table></figure>
<h3
id="step3在输出区得到需要的latex数学表达式"><strong>step3：在输出区得到需要的LaTeX数学表达式</strong></h3>
<p><strong>特别说明</strong>，生成的表达式为<strong>定义式</strong>，即
，如果只需要等式
，可以把生成表达式中的<code>\triangleq</code>改成<code>=</code> ！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/PC%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%8D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/PC%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%8D%A1/" itemprop="url">连接kuka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>电脑连接kuka机器人</p>
<p>1.使用网线连接库卡机器人驱动柜的KLI接口和电脑的网线接口</p>
<p>2.将PC的IP修改到库卡的ip同一网关下，库卡机器人ip为172.31.1.147，需将电脑ip配置为172.31.1.x。</p>
<p>若电脑要重新联网，需将ip地址修改为自动获取。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leiting-uncle/github.io/blog/2022/08/24/kuka%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/kuka%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/" itemprop="url">kuka示例程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T17:48:05+08:00">
                2022-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ethernet KRL 的供货范围包括一个服务器程序及多个示例配置和示例程序。
利用这些示例配置和示例程序，可以在服务器程序与机器人控制系统之间建立
通讯。 7.1 接入服务器程序和示例</p>
<ol type="1">
<li>将 XML 示例配置粘贴到机器人控制系统的目录 C:中。</li>
<li>将 KRL 示例程序粘贴到机器人控制系统的目录 C: 中。</li>
<li>启动外部系统上的服务器程序。(&gt;&gt;&gt; 7.2 " 服务器程序操作界面 "
页码 44)</li>
<li>按下菜单按钮。窗口通讯属性打开。(&gt;&gt;&gt; 7.2.1 "
在服务器程序中设置通讯参数 " 页码 45)</li>
<li>只有当外部系统有多个网络接口可用时：输入与机器人控制系统通讯时使用的网络适配器编号
（= 网卡索引）。</li>
<li>关闭窗口通讯属性并按下启动按钮。通讯时可用的 IP
地址会显示在信息窗口中。</li>
<li>在所需的 XML 文件中设置显示的外部系统 IP 地址。</li>
</ol>
<table>
<colgroup>
<col style="width: 72%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>组件</th>
<th>目录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>服务器程序：EthernetKRL_Server.exe</td>
<td>DOC</td>
</tr>
<tr class="even">
<td>KRL 中的示例程序 <br />BinaryFixed.src <br />BinaryStream.src
<br />XmlCallback.src <br />XmlServer.src <br />XmlTransmit.src</td>
<td>DOC</td>
</tr>
<tr class="odd">
<td>XML 中的示例配置 <br />BinaryFixed.xml <br />BinaryStream.xml
<br />XmlCallBack.xml <br />XmlServer.xml <br />XmlTransmit.xml
<br />XmlFullConfig.xml</td>
<td></td>
</tr>
</tbody>
</table>
<p>XmlServer示例</p>
<p><strong>EKI 配置为服务器。只要与外部系统存在连接，$FLAG[1]
就处于赋值状态。</strong></p>
<p>xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ETHERNETKRL</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">CONFIGURATION</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">EXTERNAL</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">TYPE</span>&gt;</span>Client<span class="tag">&lt;/<span class="name">TYPE</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">EXTERNAL</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">INTERNAL</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">IP</span>&gt;</span>x.x.x.x<span class="tag">&lt;/<span class="name">IP</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PORT</span>&gt;</span>54600<span class="tag">&lt;/<span class="name">PORT</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ALIVE</span> <span class="attr">Set_Flag</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">INTERNAL</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">CONFIGURATION</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">RECEIVE</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">XML</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ELEMENT</span> <span class="attr">Tag</span>=<span class="string">&quot;Sensor/A&quot;</span> <span class="attr">Type</span>=<span class="string">&quot;BOOL&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">XML</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">RECEIVE</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">SEND</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">XML</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ELEMENT</span> <span class="attr">Tag</span>=<span class="string">&quot;Robot/B&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">XML</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">SEND</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ETHERNETKRL</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>src程序文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 DEF XmlServer( )</span><br><span class="line">2 Declaration</span><br><span class="line">3 INI</span><br><span class="line">45</span><br><span class="line">RET=EKI_Init(&quot;XmlServer&quot;)</span><br><span class="line">6 RET=EKI_Open(&quot;XmlServer&quot;)</span><br><span class="line">78</span><br><span class="line">; wait until server is conntected</span><br><span class="line">9 wait for $FLAG[1</span><br><span class="line">10 ; wait until server is deconnected</span><br><span class="line">11 wait for $FLAG[1]==FALSE</span><br><span class="line">12</span><br><span class="line">13 RET=EKI_Clear(&quot;XmlServer&quot;)</span><br><span class="line">14 END</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lei ting</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
